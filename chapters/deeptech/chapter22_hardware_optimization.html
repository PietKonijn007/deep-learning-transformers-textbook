<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chapter 22: From PyTorch to Accelerator Silicon - Deep Learning and Transformers</title>
    <link rel="stylesheet" href="../../styles.css">
    
    <!-- MathJax Configuration (must come before loading MathJax) -->
    <script>
    window.MathJax = {
        tex: {
            inlineMath: [['$', '$'], ['\\(', '\\)']],
            displayMath: [['$$', '$$'], ['\\[', '\\]']],
            processEscapes: true,
            processEnvironments: true,
            tags: 'ams',
            macros: {
                R: '{\\mathbb{R}}',
                N: '{\\mathbb{N}}',
                Z: '{\\mathbb{Z}}',
                C: '{\\mathbb{C}}',
                va: '{\\mathbf{a}}',
                vb: '{\\mathbf{b}}',
                vc: '{\\mathbf{c}}',
                vd: '{\\mathbf{d}}',
                ve: '{\\mathbf{e}}',
                vf: '{\\mathbf{f}}',
                vg: '{\\mathbf{g}}',
                vh: '{\\mathbf{h}}',
                vi: '{\\mathbf{i}}',
                vj: '{\\mathbf{j}}',
                vk: '{\\mathbf{k}}',
                vl: '{\\mathbf{l}}',
                vm: '{\\mathbf{m}}',
                vn: '{\\mathbf{n}}',
                vo: '{\\mathbf{o}}',
                vp: '{\\mathbf{p}}',
                vq: '{\\mathbf{q}}',
                vr: '{\\mathbf{r}}',
                vs: '{\\mathbf{s}}',
                vt: '{\\mathbf{t}}',
                vu: '{\\mathbf{u}}',
                vv: '{\\mathbf{v}}',
                vw: '{\\mathbf{w}}',
                vx: '{\\mathbf{x}}',
                vy: '{\\mathbf{y}}',
                vz: '{\\mathbf{z}}',
                mA: '{\\mathbf{A}}',
                mB: '{\\mathbf{B}}',
                mC: '{\\mathbf{C}}',
                mD: '{\\mathbf{D}}',
                mE: '{\\mathbf{E}}',
                mF: '{\\mathbf{F}}',
                mG: '{\\mathbf{G}}',
                mH: '{\\mathbf{H}}',
                mI: '{\\mathbf{I}}',
                mJ: '{\\mathbf{J}}',
                mK: '{\\mathbf{K}}',
                mL: '{\\mathbf{L}}',
                mM: '{\\mathbf{M}}',
                mN: '{\\mathbf{N}}',
                mO: '{\\mathbf{O}}',
                mP: '{\\mathbf{P}}',
                mQ: '{\\mathbf{Q}}',
                mR: '{\\mathbf{R}}',
                mS: '{\\mathbf{S}}',
                mT: '{\\mathbf{T}}',
                mU: '{\\mathbf{U}}',
                mV: '{\\mathbf{V}}',
                mW: '{\\mathbf{W}}',
                mX: '{\\mathbf{X}}',
                mY: '{\\mathbf{Y}}',
                mZ: '{\\mathbf{Z}}',
                transpose: '{^\\top}',
                norm: ['\\left\\|#1\\right\\|', 1],
                abs: ['\\left|#1\\right|', 1]
            }
        },
        startup: {
            pageReady: () => {
                console.log('MathJax loaded and ready');
                return MathJax.startup.defaultPageReady();
            }
        }
    };
    </script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>
    <nav>
        <a href="../../deeptech.html">üè† Home</a>
        <a href="preface.html">Preface</a>
        <a href="notation.html">Notation</a>
        <a href="chapter01_linear_algebra.html">Ch 1</a>
        <a href="chapter02_calculus_optimization.html">Ch 2</a>
        <a href="chapter03_probability_information.html">Ch 3</a>
        <a href="chapter04_feedforward_networks.html">Ch 4</a>
        <a href="chapter05_convolutional_networks.html">Ch 5</a>
        <a href="chapter06_recurrent_networks.html">Ch 6</a>
        <a href="chapter07_attention_fundamentals.html">Ch 7</a>
        <a href="chapter08_self_attention.html">Ch 8</a>
        <a href="chapter09_attention_variants.html">Ch 9</a>
        <a href="chapter10_transformer_model.html">Ch 10</a>
        <a href="chapter11_training_transformers.html">Ch 11</a>
        <a href="chapter12_computational_analysis.html">Ch 12</a>
        <a href="chapter13_bert.html">Ch 13</a>
        <a href="chapter14_gpt.html">Ch 14</a>
        <a href="chapter15_t5_bart.html">Ch 15</a>
        <a href="chapter16_efficient_transformers.html">Ch 16</a>
        <a href="chapter17_vision_transformers.html">Ch 17</a>
        <a href="chapter18_multimodal_transformers.html">Ch 18</a>
        <a href="chapter19_long_context.html">Ch 19</a>
        <a href="chapter20_pretraining_strategies.html">Ch 20</a>
        <a href="chapter21_pytorch_implementation.html">Ch 21</a>
        <a href="chapter22_hardware_optimization.html">Ch 22</a>
        <a href="chapter23_best_practices.html">Ch 23</a>
        <a href="chapter24_domain_specific_models.html">Ch 24</a>
        <a href="chapter25_enterprise_nlp.html">Ch 25</a>
        <a href="chapter26_code_language.html">Ch 26</a>
        <a href="chapter27_video_visual.html">Ch 27</a>
        <a href="chapter28_knowledge_graphs.html">Ch 28</a>
        <a href="chapter29_recommendations.html">Ch 29</a>
        <a href="chapter30_healthcare.html">Ch 30</a>
        <a href="chapter31_finance.html">Ch 31</a>
        <a href="chapter32_legal.html">Ch 32</a>
        <a href="chapter33_observability.html">Ch 33</a>
        <a href="chapter34_dsl_agents.html">Ch 34</a>
    </nav>

    <main>
        <h1>From PyTorch to Accelerator Silicon</h1>

<h2>Chapter Overview</h2>

<p>You understand the mathematics of transformers. You know that attention is a softmax-weighted average over value vectors, that feed-forward networks are two linear projections with a nonlinearity, and that the whole structure repeats for dozens or hundreds of layers. But there is an enormous gap between understanding the math and understanding how it executes. When you write <code>output = self.attention(x)</code>, what happens? Which chip does the multiplication? How does data get there? Why does one serving configuration produce ten times the throughput of another on identical hardware?</p>

<p>This chapter is not a catalog of tricks. It is a framework for reasoning about trade-offs. Seven layers of engineering separate your Python code from the transistors. Each layer is an optimization surface with its own controls, constraints, and failure modes. Decisions at one layer propagate to others. An engineer who understands these interactions can diagnose bottlenecks, select optimizations in the right order, and avoid wasted effort.</p>

<p>We use NVIDIA H100 as the primary worked example and explicitly map every concept to AMD MI300X, Google TPU v5p, and AWS Trainium2. For PyTorch quantization implementation code (dynamic, static, and QAT), see Chapter~[ref].</p>

<h3>Learning Objectives</h3>

<ol>
    <li>Understand the seven-layer inference stack from model definition to accelerator silicon
    <li>Reason about the prefill vs.\ decode asymmetry and its optimization implications
    <li>Apply tensor, pipeline, and expert parallelism with correct communication patterns
    <li>Understand frontend runtimes: eager dispatch, lazy tensors, graph capture, compilation, and replay
    <li>Configure inference engines: continuous batching, PagedAttention, and scheduler knobs
    <li>Analyze compute-bound vs.\ memory-bound regimes using roofline reasoning
    <li>Apply model compression: quantization (FP8, INT8, INT4), pruning, and distillation
    <li>Diagnose bottlenecks systematically and select optimizations by regime
    <li>Evaluate hardware across NVIDIA, AMD, TPU, and Trainium platforms
</ol>

<h3>Three Optimization Objectives</h3>

<p>Every optimization targets one or more of three objectives. They often conflict, so you must choose which to prioritize before optimizing:</p>

<p><strong>Latency:</strong> time from request arrival to first/last token. Dominates interactive and real-time applications. Sensitive to serialized dependencies, interconnect latency, and runtime overhead.</p>

<p><strong>Throughput:</strong> tokens per second across all concurrent requests. Dominates batch and offline workloads. Sensitive to accelerator utilization, batching efficiency, and memory capacity.</p>

<p><strong>Cost-efficiency:</strong> tokens per dollar (or per watt). Dominates at scale. Often requires trading latency for throughput via larger batches, aggressive quantization, or fewer devices.</p>

<p>Numbers in this chapter are a mix of conceptual examples, representative measurements from published benchmarks, and platform-specific values. Each is labeled accordingly. Exact performance depends on model, hardware, software versions, and workload shape. Always measure on your own stack.</p>

<h2>The Two Phases of Inference: Prefill and Decode</h2>

<p>Almost every optimization decision depends on which phase dominates your workload, and the two phases have completely different performance characteristics.</p>

<p><strong>Prefill (processing the prompt).</strong> The entire prompt is processed in one forward pass. Every token in the prompt is handled simultaneously. If the prompt has 500 tokens, the model runs matrix multiplications on all 500 at once---for example, a $[500 \times 8192]$ activation matrix times a $[8192 \times 8192]$ weight matrix. Large matrix multiplications keep the GPU's compute cores busy. Prefill is \emph{compute-bound}.</p>

<p><strong>Decode (generating the response).</strong> After prefill, the model generates one token at a time. Each token requires a full forward pass through all layers, but the ``batch'' of new tokens is tiny---just one new token (or a handful if batching multiple requests). The matrix multiplication is now $[1 \times 8192]$ times $[8192 \times 8192]$. The weight matrix is exactly the same size as during prefill, but the activation vector is tiny. The GPU loads the entire weight matrix from memory just to multiply it by a single row. Decode is \emph{memory-bandwidth-bound}.</p>

<p>This distinction is critical because different bottlenecks require different optimizations:
<ul>
    <li>Making the compute cores faster (e.g., FP8) helps prefill much more than decode.
    <li>Reducing memory traffic (e.g., quantizing weights so there is less to load) helps decode much more than prefill.
    <li>Reducing communication latency (e.g., faster all-reduce) helps decode more, because decode's per-token compute is so short that even a few microseconds of communication overhead is proportionally large.
</ul>

<p>A chatbot generates thousands of decode tokens per request but prefills once, so decode performance usually dominates. A document summarization service might process very long prompts and generate short summaries, so prefill dominates instead.</p>

<h2>The Seven-Layer Inference Stack</h2>

<p>The path from PyTorch to silicon follows seven conceptual layers, numbered 7 (closest to you) down to 1 (bare metal). The top layers are portable; the bottom layers are device-specific. A single software tool (e.g., XLA) may span multiple conceptual layers. The layer model is an analytical framework, not a claim about software module boundaries.</p>

<table>
<tr><th><strong>\#</strong></th><th><strong>Layer</strong></th><th><strong>What It Controls</strong></th><th><strong>Portable?</strong></th><th><strong>Example Implementations</strong></th></tr>
<tr><td>7</td><td>Model Definition</td><td>Architecture dims, parallelism, sharding</td><td>Yes</td><td>Same <code>nn.Module</code> on all backends</td></tr>
<tr><td>6</td><td>Frontend Runtime</td><td>Eager dispatch, lazy tracing, compiled capture</td><td>Mostly</td><td>CUDA/HIP eager; XLA lazy; <code>torch.compile</code></td></tr>
<tr><td>5</td><td>Graph Compilation</td><td>Fusion, memory plan, comm scheduling</td><td>IR portable</td><td>TorchInductor; XLA HLO; NeuronX Compiler</td></tr>
<tr><td>4</td><td>Inference Engine</td><td>Batching, KV-cache mgmt, orchestration</td><td>Concepts yes</td><td>vLLM; TensorRT-LLM; NeuronX Serving</td></tr>
<tr><td>3</td><td>Device Kernels</td><td>GEMM, attention, all-reduce implementations</td><td>Concepts only</td><td>cuBLAS+NCCL; rocBLAS+RCCL; XLA; Neuron</td></tr>
<tr><td>2</td><td>Device Compiler</td><td>Final lowering to native ISA, scheduling</td><td>No</td><td>nvcc$\to$SASS; LLVM$\to$AMDGPU; XLA$\to$TPU ISA</td></tr>
<tr><td>1</td><td>Accelerator HW</td><td>Compute units, memory hierarchy, interconnect</td><td>No</td><td>H100+NVLink; MI300X+IF; TPU+ICI; Trn2</td></tr>
</table>

<p>How the layers interact: Layer~7 determines communication patterns---how often devices must talk and how much data they exchange. Layer~4 determines request shape distributions---how variable or regular the work is. Layers~5 and~2 determine how much overhead is optimized away. Layers~3 and~1 set the execution efficiency ceiling---the physical limits of how fast things can run.</p>

<div class="keypoint">[Misconception Alert]
A single tool may span multiple layers. XLA implements both graph optimization (Layer~5) and final lowering (Layer~2). vLLM orchestrates scheduling (Layer~4) and inserts collectives (affecting Layer~3). Do not assume one-to-one mapping between tools and layers.
</div>

<h3>Backend Cheat Sheet</h3>

<p>This reference maps every concept to its vendor-specific implementation. Later sections cite it rather than repeating the mapping.</p>

<table>
<tr><th><strong>Concept</strong></th><th><strong>NVIDIA (CUDA)</strong></th><th><strong>AMD (ROCm)</strong></th><th><strong>Google TPU</strong></th><th><strong>AWS Trainium</strong></th></tr>
<tr><td>Graph capture</td><td><code>torch.compile</code></td><td><code>torch.compile</code></td><td>XLA lazy/compile</td><td><code>torch\_neuronx.trace</code></td></tr>
<tr><td>IR</td><td>Inductor/Triton</td><td>Inductor+HIP</td><td>StableHLO/HLO</td><td>Neuron HLO</td></tr>
<tr><td>GEMM library</td><td>cuBLAS/CUTLASS</td><td>rocBLAS/CK</td><td>XLA GEMM</td><td>Neuron GEMM</td></tr>
<tr><td>Attention kernel</td><td>FlashAttention-2/3</td><td>CK FlashAttn</td><td>Pallas attention</td><td>Neuron attention</td></tr>
<tr><td>All-reduce</td><td>NCCL</td><td>RCCL</td><td>XLA collectives</td><td>Neuron collectives</td></tr>
<tr><td>LLM engine</td><td>vLLM, TRT-LLM</td><td>vLLM ROCm</td><td>vLLM TPU</td><td>NeuronX Serving</td></tr>
<tr><td>Graph replay</td><td>CUDA Graphs</td><td>hipGraphs</td><td>XLA executable</td><td>Neuron NEFF</td></tr>
<tr><td>Intra-node link</td><td>NVLink/NVSwitch</td><td>Infinity Fabric</td><td>ICI torus</td><td>NeuronLink</td></tr>
<tr><td>Inter-node fabric</td><td>InfiniBand NDR</td><td>InfiniBand NDR</td><td>ICI across pods</td><td>EFA (3.2~Tb/s)</td></tr>
</table>

<h3>Latency and Bandwidth Ladder</h3>

<table>
<tr><th><strong>Link Type</strong></th><th><strong>Example</strong></th><th><strong>BW (bidi)</strong></th><th><strong>Latency</strong></th><th><strong>Scope</strong></th><th><strong>Use Case</strong></th></tr>
<tr><td>NVLink 4.0</td><td>H100 (8 GPUs)</td><td>900~GB/s</td><td>$\sim$1--2~$\mu$s</td><td>Intra-node</td><td>TP, EP</td></tr>
<tr><td>NVLink 5.0</td><td>B200 (72 via NVSwitch)</td><td>1.8~TB/s</td><td>$\sim$1--2~$\mu$s</td><td>Multi-rack</td><td>Extended TP</td></tr>
<tr><td>ICI torus</td><td>TPU v5p pod slice</td><td>Multi-TB/s</td><td>$\sim$1--3~$\mu$s</td><td>Within pod</td><td>TP/EP</td></tr>
<tr><td>Infinity Fabric</td><td>MI300X (8 GPUs)</td><td>$\sim$896~GB/s</td><td>$\sim$2--3~$\mu$s</td><td>Intra-node</td><td>TP, EP</td></tr>
<tr><td>NeuronLink</td><td>Trn2 (16 chips)</td><td>$\sim$1.6~TB/s</td><td>$\sim$few~$\mu$s</td><td>Intra-instance</td><td>TP</td></tr>
<tr><td>InfiniBand NDR</td><td>Multi-node cluster</td><td>400~Gb/s/port</td><td>$\sim$5--10~$\mu$s</td><td>Cross-node</td><td>PP, param sync</td></tr>
<tr><td>EFA</td><td>AWS instances</td><td>3.2~Tb/s/inst</td><td>$\sim$5--15~$\mu$s</td><td>Cross-node</td><td>PP, cross-inst EP</td></tr>
</table>

<h2>Layer 7: The Model Definition</h2>

<p>When you define a transformer in PyTorch, you lock in decisions that propagate through every layer below.</p>

<p><strong>Tensor shapes:</strong> hidden dimension $H$, head count, KV-head count, FFN intermediate size, layer count. These determine every GEMM shape, every collective message size, and the memory footprint breakdown.</p>

<p><strong>Divisibility constraints:</strong> head counts must divide evenly by TP degree. KV-head counts must also divide. FFN dimensions affect kernel tile efficiency.</p>

<p><strong>Communication patterns:</strong> TP degree fixes the number and frequency of all-reduces. PP depth fixes stage boundary point-to-point transfers. EP determines all-to-all topology requirements.</p>

<p><strong>Memory footprint classes:</strong> model weights, KV-cache per token, activation memory per layer. Each scales differently with parallelism.</p>

<div class="keypoint">[What Layer 7 Cannot Fix Later]
Poor divisibility (e.g., 8 KV-heads with TP-3 gives $8/3$ which is not integer), hidden dimensions misaligned with kernel tile sizes (typically multiples of 128), or an architecture whose communication volume exceeds interconnect capacity at the target TP degree.
</div>

<h3>Why Multi-Device Execution Is Required</h3>

<p>Multi-device execution is required for three distinct reasons, and they are not equivalent:</p>

<p><strong>Parameter memory fit.</strong> A 70B model needs $\sim$140~GB in BF16 ($70 \times 10^9 \times 2$ bytes). An H100 has 80~GB, a TPU~v5p has 95~GB, and a Trainium2 has 96~GB---the weights alone do not fit. MI300X at 192~GB can hold 70B weights plus meaningful KV-cache on one device, but this is the exception.</p>

<p><strong>KV-cache fit.</strong> Even if weights fit, the KV-cache can be enormous. For a 70B model with 128K context length and 80 layers, a single request at full context can require 10+~GB. A few concurrent requests exhaust remaining memory.</p>

<p><strong>Throughput and latency targets.</strong> Even if everything fits, a single device may not meet requirements. A single GPU must stream all 140~GB of weights through memory for every decode token---that alone takes $\sim$42~ms at 3.35~TB/s on H100. Splitting weights across 4 GPUs means each streams only 35~GB, roughly $4\times$ faster.</p>

<h3>Tensor Parallelism: Splitting Weight Matrices</h3>

<h4>What All-Reduce Actually Does</h4>

<p>Imagine four devices, each holding a number: Device~0 has 10, Device~1 has 20, Device~2 has 30, Device~3 has 40. An all-reduce(sum) computes the sum ($10 + 20 + 30 + 40 = 100$) and distributes the result to every device. After the all-reduce, all four devices hold the value 100.</p>

<p>In LLM inference, the ``numbers'' are tensors---vectors or matrices of thousands of floating-point values. When TP splits a weight matrix across devices, each device computes a partial result. The all-reduce sums these partial results so every device gets the complete answer.</p>

<p>Two critical characteristics of all-reduce determine TP's performance impact:</p>

<p><strong>Frequency:</strong> a standard transformer block requires two all-reduces per layer (one after the attention output projection, one after the FFN down-projection). For an 80-layer model, that is 160 all-reduces per token generated.</p>

<p><strong>Message size:</strong> during decode, the data being summed is a vector of size $[H]$ in the chosen precision. For $H=8192$ in BF16: $8192 \times 2 = 16{,}384$ bytes $= 16$~KB. At 900~GB/s of NVLink bandwidth, 16~KB transfers in nanoseconds---but the latency of initiating the all-reduce ($\sim$1--2~$\mu$s) dominates. This is why decode TP performance is \emph{latency-bound}, not bandwidth-bound.</p>

<h4>Column-Parallel and Row-Parallel GEMMs</h4>

<p>TP splits weight matrices across devices using two deliberately paired patterns.</p>

<p><strong>Column-parallel GEMM (no communication needed).</strong> Split weight matrix $\mW$ with shape $[8192 \times 8192]$ by columns: Device~0 gets $[8192 \times 4096]$, Device~1 gets $[8192 \times 4096]$. Input $\vx\,[1 \times 8192]$ goes to both devices. Each produces half the output. No communication needed---but each device only has half the result.</p>

<p><strong>Row-parallel GEMM (all-reduce required).</strong> The next weight matrix is split by rows. Each device multiplies its local input half by its local weight half, producing partial sums $[1 \times 8192]$. These must be summed via all-reduce to get the correct result.</p>

<div class="keypoint">[The Megatron-LM Pairing]
By alternating column-parallel then row-parallel within each transformer block, the column-parallel output feeds directly as the row-parallel input. Only the row-parallel step needs an all-reduce. A standard transformer block has two such pairs (attention: QKV column-parallel $\to$ output row-parallel; FFN: gate/up column-parallel $\to$ down row-parallel), so each layer needs exactly two all-reduces. This pattern works identically on any hardware that supports all-reduce.
</div>

<p><strong>Per-layer communication volume.</strong> Bytes per all-reduce per device $= H \times p$, where $p$ = bytes per element. Per layer: $2 \times H \times p$. For decode with $H=8192$, BF16: $2 \times 8192 \times 2 = 32$~KB per layer. For 80 layers: $\sim$2.6~MB total.</p>

<div class="example"><strong>Example:</strong> 
Trace one transformer layer with TP-2. $H=8192$, 32 query heads (GQA: 8 KV-heads, $d_{\text{head}}=256$), FFN$=22016$. Decode: $B=1$, $S=1$. All values BF16.

<p><strong>Step 1 --- QKV Projection (column-parallel, NO communication).</strong> Both devices receive the same input $\vx\,[1 \times 8192]$. Each multiplies by its local Q, K, V column shards. Device~0 produces: $\mQ_0\,[1 \times 4096]$ (heads 0--15), $\mK_0\,[1 \times 512]$ (KV-heads 0--3), $\mV_0\,[1 \times 512]$.</p>

<p><strong>Step 2 --- Attention (local, NO communication).</strong> Each device runs attention on its own heads against its own KV-cache shard. Completely independent per device.</p>

<p><strong>Step 3 --- Output Projection + ALL-REDUCE.</strong> Row-parallel step. Each device computes partial $= [1 \times 4096] \times [4096 \times 8192] = [1 \times 8192]$. All-reduce sums them. Data transferred: $8192 \times 2 = 16$~KB per device.</p>

<p><strong>Steps 4--5 --- FFN (same column$\to$row pattern).</strong> Column-parallel gate+up (no communication), local SwiGLU, row-parallel down + all-reduce (another 16~KB).</p>

<p><strong>Total for this layer:</strong> 2 all-reduces, 32~KB moved. For 80 layers: 160 all-reduces, $\sim$2.6~MB. At NVLink latencies of $\sim$1--2~$\mu$s per all-reduce, communication overhead is $\sim$160--320~$\mu$s per token. On slow interconnects (InfiniBand at $\sim$5--10~$\mu$s), the same 160 all-reduces cost 800--1600~$\mu$s---up to 30\% overhead. This is why TP must use the fastest available link.
</div>

<h3>Pipeline Parallelism</h3>

<p>While TP splits every layer across devices, PP assigns entire layers to different devices. Device~0 computes layers 0--39; Device~1 computes layers 40--79. Each device holds complete, unsharded weights for its assigned layers.</p>

<p>Communication is point-to-point: after Device~0 finishes, it sends the activation tensor to Device~1. During prefill with a 2048-token prompt: activation $= [1 \times 2048 \times 8192] \times 2$ bytes $= 32$~MB. But this transfer happens only once per stage boundary, not once per layer. During decode ($S=1$): only 16~KB. PP therefore tolerates higher-latency links.</p>

<p><strong>Pipeline bubble:</strong> the key drawback. With simple scheduling, the fraction of time wasted to bubbles is roughly $1/\text{PP\_degree}$. Micro-batching reduces this by feeding multiple small batches in rapid succession. Decode is particularly vulnerable because each micro-batch has so little compute that communication latency between stages becomes proportionally larger.</p>

<h3>Expert Parallelism</h3>

<p>EP is specific to Mixture-of-Experts (MoE) models, where each transformer layer has multiple ``expert'' FFN blocks and a router that sends each token to only 1--2 experts. EP places different experts on different devices. The communication pattern is all-to-all: every device may need to send tokens to every other device.</p>

<p>All-to-all is the most interconnect-demanding collective. This is where bisection bandwidth matters: if you split 8 devices into two groups of 4, the total bandwidth between the groups determines how fast all-to-all runs. NVSwitch provides full bisection bandwidth for 8 GPUs. InfiniBand and EFA between nodes typically do not provide sufficient bisection bandwidth for efficient cross-node EP.</p>

<p><strong>Routing skew risk:</strong> if the router disproportionately sends tokens to a few experts, those devices become bottlenecks while others idle. Load-balancing losses and capacity factors in the model architecture (Layer~7) directly affect hardware utilization at Layers~3/1.</p>

<p>Multiple specialized EP kernel libraries have emerged for inter-node communication:</p>

<table>
<tr><th><strong>Aspect</strong></th><th><strong>DeepEP</strong></th><th><strong>PPLX-Kernels</strong></th><th><strong>UCCL-EP</strong></th><th><strong>NCCL a2a</strong></th></tr>
<tr><td>GPU vendor</td><td>NVIDIA only</td><td>NVIDIA only</td><td>NVIDIA + AMD</td><td>NVIDIA (+AMD)</td></tr>
<tr><td>NIC requirement</td><td>Mellanox CX (IB)</td><td>EFA or IB</td><td>Any RDMA</td><td>Any</td></tr>
<tr><td>GPU-to-NIC path</td><td>IBGDA (direct)</td><td>NVSHMEM+libfabric</td><td>CPU proxy</td><td>CPU-initiated</td></tr>
<tr><td>FP8 support</td><td>Native</td><td>Native + block scaling</td><td>Native</td><td>Via framework</td></tr>
<tr><td>Cloud deployment</td><td>On-prem IB</td><td>AWS (EFA) + IB</td><td>AWS, GCP, on-prem</td><td>Any</td></tr>
</table>

<h3>Context Parallelism and Sequence Parallelism</h3>

<p><strong>Context Parallelism (CP)</strong> addresses what happens when the sequence is so long that the KV-cache for a single request does not fit on one device. CP splits the sequence across devices. Ring attention is the most common implementation: devices are arranged in a logical ring, each computing attention for its local chunk against its local KV block, then passing its KV block to the next device.</p>

<p><strong>Sequence Parallelism (SP)</strong> is a refinement of TP that reduces memory usage. In standard TP, activations between GEMMs are replicated on every device. SP uses reduce-scatter (each device gets $1/P$ of the result) followed by a deferred all-gather. Between GEMMs, each device holds only $1/P$ of the activations. Total communication volume is the same, but peak activation memory drops by the TP degree.</p>

<h3>Parallelism Selection Framework</h3>

<table>
<tr><th><strong>Scenario</strong></th><th><strong>Start with</strong></th><th><strong>Why</strong></th><th><strong>Watch out for</strong></th></tr>
<tr><td>Dense model, doesn't fit</td><td>TP first, then PP</td><td>TP distributes every layer</td><td>TP beyond NVLink domain</td></tr>
<tr><td>Decode latency critical</td><td>TP, minimize degree</td><td>Each TP AR adds latency</td><td>Over-aggressive TP</td></tr>
<tr><td>Long context, high concurrency</td><td>TP + CP or KV quant</td><td>KV-cache dominates memory</td><td>CP ring overhead</td></tr>
<tr><td>MoE model</td><td>EP first, TP within</td><td>EP native to MoE</td><td>All-to-all needs bisection BW</td></tr>
</table>

<h2>Layer 6: Frontend Runtime</h2>

<p>This layer determines how Python model code translates into work that lower layers execute. It controls execution semantics (eager vs.\ lazy vs.\ compiled dispatch), Python-to-accelerator overhead, and how operations are grouped before graph compilation.</p>

<h3>Eager Mode (NVIDIA, AMD)</h3>

<p>Default PyTorch on CUDA/ROCm: each operation dispatches immediately. When your code calls <code>torch.matmul(x, W)</code>, PyTorch's C++ dispatcher selects a kernel, launches it on the GPU, and returns control to Python. Each dispatch involves Python interpreter overhead, C++ dispatch, kernel launch, and potentially synchronization.</p>

<p>For large operations (e.g., a big prefill GEMM that takes milliseconds), this overhead is negligible. But during decode with TP-4, individual GEMMs on tiny tensors may take only 5--15~$\mu$s of actual compute. If every dispatch adds 3--5~$\mu$s of overhead, the overhead is 20--50\% of compute time.</p>

<h3>Lazy Tensor Mode (TPU, Trainium)</h3>

<p>On TPU, PyTorch/XLA records operations into a graph instead of executing each immediately. Operations accumulate until an explicit barrier (<code>xm.mark\_step()</code>), at which point XLA compiles the entire graph, caches the result, and dispatches it as a single unit. The advantage: XLA can optimize many operations together. The downside: debugging is harder because errors surface only at compilation time. Trainium supports both lazy tensors (via XLA) and <code>torch.compile</code> (via torch-neuronx).</p>

<h3>Graph Capture, Compilation, and Replay</h3>

<p>These three concepts are frequently conflated but are distinct steps with different costs and benefits.</p>

<div class="definition"><strong>Definition:</strong> 
<strong>Step 1: Graph capture</strong> records what operations to perform, in what order, with what tensor shapes---without executing them. Mechanisms: <code>torch.compile</code> (Dynamo traces Python), XLA lazy tensors, <code>torch\_neuronx.trace</code>. Capture alone provides almost no performance benefit.

<p><strong>Step 2: Graph compilation</strong> (Layer~5) optimizes the captured graph: fusing operations, planning memory layout, scheduling communication. Compilation can take seconds to minutes, but produces much faster execution.</p>

<p><strong>Step 3: Graph replay</strong> (Layer~2) re-executes a compiled graph with new input data---as long as tensor shapes are identical. On NVIDIA: CUDA Graphs. On AMD: hipGraphs. On TPU: XLA cached executables. On Trainium: Neuron NEFFs. Replay skips both capture and compilation entirely.
</div>

<p>The three steps are cumulative: capture alone does little, capture + compilation gives moderate benefit, capture + compilation + replay gives the full benefit. For production serving, all three are essential.</p>

<div class="keypoint">[Why Replay Requires Static Shapes]
The compiled execution plan includes specific memory addresses, buffer sizes, and kernel launch configurations that depend on tensor dimensions. If you change the batch size from 16 to 17, every buffer size changes and the old plan is invalid. Shape bucketing (Section~[ref]) addresses this by pre-compiling plans for a fixed set of shapes.
</div>

<h3>Process Groups and Communicators</h3>

<p>Multi-device collectives require process groups that define which devices participate together. In a TP-4, PP-2 deployment on 8 devices: two TP groups exist (devices $[0,1,2,3]$ and $[4,5,6,7]$). Four PP groups exist as device pairs across stages (e.g., $[0,4]$, $[1,5]$). Model code (Layer~7) defines group shapes; the serving framework (Layer~4) instantiates them; the communication library (Layer~3) automatically selects the best algorithm.</p>

<h2>Layer 5: Graph Compilation</h2>

<p>Graph compilation transforms a captured operation graph into an optimized execution plan. It controls which operations are fused, how memory is allocated and reused, how communication is scheduled relative to computation, and what IR is emitted for the device compiler.</p>

<h3>Four Optimization Mechanisms</h3>

<p><strong>1. Host overhead elimination.</strong> Replaces per-op Python dispatch with a single graph launch. Most impactful for decode, where individual operations are tiny.</p>

<p><strong>2. Memory traffic reduction via fusion.</strong> Combines operations that share intermediate tensors into fused kernels. Without fusion, each intermediate is written to HBM and read back. Fusion keeps intermediates in fast on-chip memory. Most impactful for prefill, where intermediate tensors are large.</p>

<p><strong>3. Memory layout planning.</strong> Optimizes tensor arrangement in memory (row-major vs.\ column-major) to match downstream kernel access patterns. Poor layout can halve bandwidth utilization.</p>

<p><strong>4. Communication scheduling.</strong> Overlaps collective communication with computation by scheduling them on separate hardware resources. Impactful whenever TP all-reduce is on the critical path.</p>

<h3>Fusion Taxonomy</h3>

<p>Vendor documentation uses ``fusion'' to mean three very different things. Confusing them leads to incorrect performance reasoning.</p>

<p><strong>Operator fusion</strong> combines multiple logical operations into a single kernel launch. Example: GEMM $\to$ bias add $\to$ ReLU becomes one kernel. Intermediate results never leave on-chip memory.</p>

<p><strong>Kernel fusion</strong> is a specialized, hand-written kernel implementing a complex multi-step computation internally. The canonical example is FlashAttention: instead of computing $\mQ\mK\transpose$ (writing the enormous $N \times N$ attention matrix to HBM), applying softmax, then multiplying by $\mV$, FlashAttention does all of this inside a single kernel by tiling the computation into blocks that fit in shared memory (228~KB on H100). For a 2048-token sequence, the naive attention matrix would be $2048 \times 2048 \times 2$ bytes $= 8$~MB---FlashAttention eliminates this entirely from HBM traffic.</p>

<p><strong>Schedule overlap</strong> runs communication and computation simultaneously on different hardware resources. A GPU has Tensor Cores for compute and NVLink controllers for communication---physically different silicon that can operate in parallel. This is not fusion; the operations remain separate.</p>

<div class="example"><strong>Example:</strong> 
Consider layer normalization followed by dropout on a tensor of shape $[32, 128, 768]$.

<p><strong>Unfused:</strong> Layer norm kernel reads/writes 3.1M elements; dropout kernel reads/writes 3.1M elements. Total memory traffic: 24.8~MB (FP16). Time: 0.18~ms.</p>

<p><strong>Fused:</strong> Single kernel reads/writes 3.1M elements. Total traffic: 12.4~MB. Time: 0.10~ms. The $1.8\times$ speedup comes from halving memory traffic. For a 12-layer transformer, this fusion appears 24 times per forward pass.
</div>

<h3>Static Shapes and Shape Bucketing</h3>

<p>Graph replay requires that every tensor has exactly the same shape as when compiled. Real inference requests have variable sequence lengths. The solution is \emph{shape bucketing}: the inference engine rounds each request's dimensions up to the nearest bucket boundary (e.g., $[64, 128, 256, 512, 1024, 2048, 4096]$). Each bucket has a pre-compiled graph. More buckets means less padding waste but a larger compile cache.</p>

<h3>When Compilation Hurts</h3>

<p><strong>Compile time:</strong> initial compilation can take seconds to minutes. For short-running jobs, this overhead may dominate.</p>

<p><strong>Graph breaks:</strong> if the compiler encounters an unsupported operation, it falls back to eager mode for that region. A single graph break can negate most compilation benefits.</p>

<p><strong>Shape churn:</strong> on XLA and Neuron, every new tensor shape triggers a new compilation. Without bucketing, variable-length requests cause continuous recompilation.</p>

<p>For production serving, compilation costs are amortized over millions of requests and almost always worthwhile. For development and debugging, eager mode provides faster iteration.</p>

<h2>Layer 4: Inference Engines</h2>

<p>Inference engines are purpose-built LLM serving runtimes. They control which requests to process and when (admission and scheduling), how to group requests (batching), where to store the KV-cache and when to evict it (memory management), and how to distribute work across devices (orchestration). End-to-end gains from a well-configured inference engine are typically 3--20$\times$ over naive PyTorch inference.</p>

<h3>Continuous Batching</h3>

<p>In static batching, you collect $N$ requests, pad them to the same length, process the entire batch, and wait for every request to finish. If one request generates 10 tokens and another generates 500, the first request's GPU resources sit idle until the 500-token request completes.</p>

<p>Continuous batching (also called iteration-level batching) checks the state of every request at every decode iteration. When a request finishes, the scheduler immediately inserts a new request into the freed slot. The GPU stays saturated instead of idling.</p>

<h4>Scheduler Knobs</h4>

<p><strong>Max batch size</strong> limits concurrent active requests. During decode, each request contributes one token to the per-iteration GEMM. A batch of 16 means $[16 \times H]$; a batch of 256 means $[256 \times H]$. Increasing batch size improves arithmetic intensity until the GEMM becomes compute-bound. Too low: poor GPU utilization. Too high: KV-cache memory exhaustion and increased inter-token latency (ITL).</p>

<p><strong>Max tokens per iteration</strong> limits total tokens (prefill + decode) per scheduler step. A large prefill can monopolize an iteration, spiking ITL for all active decode requests. Chunked prefill---splitting long prompts across iterations---is the standard solution.</p>

<p><strong>Admission policy</strong> determines which waiting request to admit next. FIFO is simplest but causes head-of-line blocking. Priority queues enable SLO differentiation. Shortest-job-first minimizes average latency but requires length estimation.</p>

<p><strong>Preemption policy</strong> determines what happens when KV-cache memory runs out. Options: swap KV to CPU (preserves state, costs PCIe bandwidth), recomputation (discards KV, re-prefills later), or request rejection.</p>

<table>
<tr><th><strong>Knob</strong></th><th><strong>Controls</strong></th><th><strong>Increase $\to$</strong></th><th><strong>Decrease $\to$</strong></th><th><strong>Trade-off</strong></th></tr>
<tr><td>Max batch size</td><td>Concurrent requests</td><td>$\uparrow$ Throughput, $\uparrow$ ITL</td><td>$\downarrow$ Throughput, $\downarrow$ ITL</td><td>Throughput vs.\ latency</td></tr>
<tr><td>Max tokens/step</td><td>Prefill chunk size</td><td>$\uparrow$ Prefill tput, $\uparrow$ ITL spikes</td><td>Better ITL protection</td><td>TTFT vs.\ ITL</td></tr>
<tr><td>Admission policy</td><td>Request ordering</td><td>(varies by policy)</td><td>(varies)</td><td>Fairness vs.\ efficiency</td></tr>
<tr><td>Preemption policy</td><td>Memory overflow</td><td>(swap/recompute/reject)</td><td>(varies)</td><td>Latency vs.\ memory</td></tr>
</table>

<h3>PagedAttention: Virtual Memory for the KV-Cache</h3>

<p>The KV-cache stores key and value vectors from every token processed so far. The naive approach allocates a contiguous block per request sized for the maximum context length, wasting 60--80\% of KV memory on average.</p>

<p>PagedAttention, inspired by OS virtual memory, divides the KV-cache into small fixed-size pages (e.g., 16 tokens per page). A page table maps each request to its pages. As a request grows, new pages are allocated on demand. When a request finishes, pages are immediately freed.</p>

<p><strong>Benefits:</strong> no internal fragmentation; memory utilization jumps dramatically; prefix caching allows shared system-prompt pages across requests.</p>

<p><strong>Cost:</strong> attention kernels must follow the page table to find each KV block, adding pointer indirection. Optimized block-sparse attention kernels minimize this overhead.</p>

<h3>vLLM and PagedAttention</h3>

<p>vLLM is a production-grade LLM serving system that maximizes throughput by managing KV-cache memory with near-zero waste. Its core contribution is PagedAttention: instead of storing each sequence's KV-cache in a single contiguous buffer, vLLM partitions the cache into fixed-size ``KV blocks'' and maintains a block table mapping logical positions to physical blocks. This indirection enables fine-grained sharing and compaction.</p>

<p>During inference, new tokens are appended by allocating additional KV blocks and updating the block table, without relocating existing data. When a request finishes, its blocks are recycled immediately. Empirical evaluations show vLLM delivers 2--4$\times$ higher throughput than earlier systems at similar latency, with gains increasing for longer contexts.</p>

<h3>Multi-Device Orchestration</h3>

<p>In vLLM, linear layers are wrapped in TP-aware modules at model load time, weights are sharded across devices, and all-reduce calls are inserted after each row-parallel GEMM. For decode's tiny all-reduce messages ($\sim$16~KB), vLLM includes custom small-message kernels that bypass general-purpose NCCL overhead. The engine architecture (scheduler, cache manager, router) is backend-agnostic: vLLM supports CUDA, ROCm, and TPU backends.</p>

<h3>Request Lifecycle</h3>

<ol>
    <li><strong>Admission:</strong> scheduler checks KV-cache page availability and batch capacity. If insufficient, queues, preempts, or rejects.
    <li><strong>Prefill:</strong> full prompt processed in one forward pass. Large, compute-heavy GEMMs. KV-cache pages allocated as KV vectors are computed.
    <li><strong>Decode loop:</strong> one token per iteration. Scheduler selects batch $\to$ graph replay launches compiled decode graph $\to$ local GEMMs and attention $\to$ all-reduces synchronize TP $\to$ logits sampled.
    <li><strong>Completion:</strong> KV-cache pages reclaimed, batch slot freed, next waiting request admitted.
</ol>

<h3>Throughput vs.\ Latency Tuning Profiles</h3>

<table>
<tr><th><strong>Dimension</strong></th><th><strong>Interactive (latency-optimized)</strong></th><th><strong>Batch (throughput-optimized)</strong></th></tr>
<tr><td>Target metric</td><td>TTFT, ITL</td><td>Tokens/second/dollar</td></tr>
<tr><td>Batch size</td><td>Small (1--16)</td><td>Large (64--512)</td></tr>
<tr><td>TP degree</td><td>Moderate (TP-2 or TP-4)</td><td>Higher OK (TP-4 or TP-8)</td></tr>
<tr><td>Graph replay</td><td>Essential for decode</td><td>Helpful, less critical</td></tr>
<tr><td>Quantization</td><td>Conservative (FP8 or BF16)</td><td>Aggressive (FP8 + KV quant)</td></tr>
<tr><td>KV-cache</td><td>PagedAttention + prefix caching</td><td>PagedAttention + large page pool</td></tr>
</table>

<h2>Layer 3: Device Kernels and Collectives</h2>

<p>This layer provides hardware-tuned implementations of compute (GEMM, attention) and communication (all-reduce, all-to-all) operations. It controls memory access patterns, on-chip data reuse, instruction scheduling, and collective algorithms.</p>

<h3>The Memory Hierarchy Problem</h3>

<p>The gap between an untuned implementation and a hardware-optimized kernel is often 10--20$\times$ for GEMM. The reason is the memory hierarchy:</p>

<table>
<tr><th><strong>Level</strong></th><th><strong>H100</strong></th><th><strong>MI300X</strong></th><th><strong>TPU v5p</strong></th><th><strong>Relative Cost</strong></th></tr>
<tr><td>Registers</td><td>256KB/SM</td><td>Similar/CU</td><td>VRF/MXU</td><td>$1\times$ (fastest)</td></tr>
<tr><td>Shared/Local memory</td><td>228KB/SM</td><td>64KB LDS/CU</td><td>CMEM (on-chip)</td><td>$\sim$5--10$\times$ slower</td></tr>
<tr><td>L2 cache</td><td>50MB</td><td>256MB</td><td>Compiler-managed</td><td>$\sim$20--50$\times$ slower</td></tr>
<tr><td>HBM (main memory)</td><td>80GB, 3.35TB/s</td><td>192GB, 5.3TB/s</td><td>95GB, 2.76TB/s</td><td>$\sim$100--500$\times$ slower</td></tr>
</table>

<p>A naive matrix multiplication loads each element from HBM multiple times. A tuned kernel \emph{tiles} the computation: it loads a block into fast shared memory, does all multiplications that need that block, then loads the next block. FlashAttention is the poster child: standard attention writes the $N \times N$ score matrix to HBM and reads it back multiple times. FlashAttention tiles all three steps (Q$\times$K, softmax, $\times$V) so the score matrix never leaves shared memory.</p>

<h3>Compute-Bound vs.\ Memory-Bound: The Roofline</h3>

<div class="definition"><strong>Definition:</strong> 
Arithmetic intensity measures FLOPs per byte loaded from memory:
<div class="equation">
$$
\text{Arithmetic Intensity} = \frac{\text{FLOPs}}{\text{Bytes transferred}}
$$
</div>
A kernel is compute-bound if its arithmetic intensity exceeds the hardware's ops:byte ratio; memory-bound otherwise. For H100: $990\text{ TFLOPS} / 3.35\text{ TB/s} \approx 295$ FLOPs/byte.
</div>

<div class="example"><strong>Example:</strong> 
<strong>Decode</strong> ($B=1$): GEMM $[1 \times 8192] \times [8192 \times 8192]$. Compute: $2 \times 8192^2 = 134$M FLOPs. Weight matrix: $128$~MB. Intensity $\approx 1$ FLOP/byte. Massively below the 295 balance point---\emph{entirely memory-bandwidth-bound}. Tensor Cores finish instantly, then sit idle waiting for weights.

<p><strong>Prefill</strong> ($B=256$): GEMM $[256 \times 8192] \times [8192 \times 8192]$. Compute: $34.4$B FLOPs. Weights still $128$~MB. Intensity $\approx 269$ FLOPs/byte---near the balance point. Compute and memory are roughly balanced.</p>

<p>This is why FP8 helps prefill much more than decode: prefill is near-compute-bound, so doubling TFLOPS roughly doubles throughput. Decode is bandwidth-bound, so doubling TFLOPS does nothing.
</div>

<h3>Coalesced Memory Access and Bank Conflicts</h3>

<p>When threads in a warp access global memory, the hardware attempts to combine accesses into a single transaction. Coalesced access (consecutive threads accessing consecutive locations) allows one 128-byte transaction instead of 32 separate ones. For transformer operations, ensuring consecutive threads load consecutive elements of the query matrix allows full bandwidth utilization.</p>

<p>Shared memory is divided into 32 banks. When multiple threads access the same bank at different addresses, a bank conflict serializes the accesses. Careful padding of shared memory tiles eliminates conflicts.</p>

<div class="example"><strong>Example:</strong> 
Computing $\mA = \mQ\mK\transpose$ with tiles loaded into shared memory:

<p><strong>Unoptimized:</strong> Tile $64 \times 64$ FP16 values (8192 bytes). 32-way bank conflicts when accessing columns. Effective bandwidth: 50~GB/s (3\% of peak).</p>

<p><strong>Optimized with padding:</strong> Tile $64 \times 72$ FP16 values (9216 bytes, 8 elements padding per row). No bank conflicts. Effective bandwidth: 1.4~TB/s (88\% of peak). The 12.5\% increase in shared memory usage yields $28\times$ bandwidth improvement.
</div>

<h3>Flash Attention</h3>

<p>Standard attention implementations compute $\mA = \mQ\mK\transpose$, write $\mA$ to HBM, read it back for softmax, write the result, read it again for multiplication with $\mV$. This results in $O(n^2)$ memory reads and writes.</p>

<p>Flash Attention restructures the computation to work on tiles that fit in shared memory, computing attention for one tile at a time and only writing the final output. This reduces memory traffic from $O(n^2)$ to $O(n)$.</p>

<div class="example"><strong>Example:</strong> 
BERT-base with sequence length 512, batch size 16, on A100 GPU:

<p><strong>Standard attention:</strong> 48~GB memory traffic, 8.2~ms, 45\% bandwidth utilization.</p>

<p><strong>Flash Attention:</strong> 12~GB traffic ($4\times$ reduction), 3.8~ms ($2.2\times$ speedup), 82\% utilization.</p>

<p>At sequence length 2048: $3.5\times$ speedup. At 8192: $5.2\times$ speedup while also enabling sequences that would otherwise exceed memory.
</div>

<h3>Collective Communication</h3>

<p>All-reduce, all-gather, reduce-scatter, all-to-all, and point-to-point are the five collective primitives. Each platform implements them through specialized libraries (see Table~[ref]). The library automatically selects the best algorithm: latency-optimized for small messages (decode's 16~KB), bandwidth-optimized (ring or tree) for large messages (prefill's multi-MB).</p>

<h3>Kernel Failure Modes</h3>

<p><strong>Shape misalignment:</strong> dimensions not aligned to tile sizes (e.g., not multiples of 128) cause padding waste or fallback to slower kernels.</p>

<p><strong>Tiny messages:</strong> all-reduce for small decode tensors is latency-dominated regardless of bandwidth.</p>

<p><strong>Register pressure:</strong> aggressively fusing many operations increases register usage, potentially reducing occupancy and overall throughput.</p>

<p><strong>Local speedup, global bottleneck:</strong> a $2\times$ faster kernel does not help if the bottleneck is scheduler overhead (Layer~4) or interconnect latency (Layer~1). Always verify that optimizing a kernel helps the end-to-end metric.</p>

<h2>Layers 2 and 1: Device Compiler and Accelerator Hardware</h2>

<h3>Layer 2: Device Compiler and Runtime</h3>

<p>Layer~2 takes the optimized graph from Layer~5 and produces native machine instructions. It controls register allocation, instruction scheduling, memory coalescing, occupancy tuning, and execution dispatch.</p>

<table>
<tr><th><strong>Aspect</strong></th><th><strong>NVIDIA CUDA</strong></th><th><strong>AMD ROCm</strong></th><th><strong>Google TPU</strong></th><th><strong>AWS Trainium</strong></th></tr>
<tr><td>Compiler</td><td>nvcc $\to$ PTX $\to$ SASS</td><td>hipcc $\to$ LLVM $\to$ AMDGPU</td><td>XLA HLO $\to$ TPU ISA</td><td>Neuron Compiler</td></tr>
<tr><td>User control</td><td>High</td><td>High</td><td>Low (XLA manages)</td><td>Low (Neuron manages)</td></tr>
<tr><td>Execution</td><td>CUDA streams + Graphs</td><td>HIP streams + hipGraphs</td><td>XLA scheduling</td><td>Neuron runtime + NEFF</td></tr>
<tr><td>Profiling</td><td>Nsight, nvprof</td><td>rocprof, ROCm SMI</td><td>XLA/TPU profiler</td><td>Neuron monitor</td></tr>
</table>

<p>Most Layer~2 effects are influenced indirectly via Layer~4/5 choices (graph structure, shape regularity), not by direct user intervention.</p>

<h3>Layer 1: Accelerator Hardware</h3>

<p>Hardware sets the ceiling on execution efficiency. Software stack maturity can dramatically affect how much of the ceiling is actually reached---a mature stack may achieve 60--70\% of peak while an immature one achieves 20--30\%.</p>

<table>
<tr><th><strong>Spec (per chip)</strong></th><th><strong>H100 SXM</strong></th><th><strong>B200 SXM</strong></th><th><strong>MI300X</strong></th><th><strong>TPU v5p</strong></th><th><strong>Trn2</strong></th></tr>
<tr><td>Compute units</td><td>132 SMs</td><td>192 SMs</td><td>304 CUs</td><td>4 MXUs/chip</td><td>32 NeuronCores</td></tr>
<tr><td>BF16 peak TFLOPS</td><td>990</td><td>$\sim$2,250</td><td>1,307</td><td>$\sim$459</td><td>$\sim$380</td></tr>
<tr><td>HBM capacity</td><td>80~GB HBM3</td><td>192~GB HBM3e</td><td>192~GB HBM3</td><td>95~GB HBM2e</td><td>96~GB HBM</td></tr>
<tr><td>HBM bandwidth</td><td>3.35~TB/s</td><td>8~TB/s</td><td>5.3~TB/s</td><td>2.76~TB/s</td><td>$\sim$1.6~TB/s</td></tr>
<tr><td>FP8 support</td><td>Native</td><td>Native</td><td>Native</td><td>INT8/FP8-like</td><td>Native FP8</td></tr>
</table>

<h3>How to Read Spec Sheets Without Fooling Yourself</h3>

<p><strong>Peak TFLOPS $\neq$ LLM performance.</strong> Decode is memory-bandwidth-bound. A chip with $2\times$ the TFLOPS but similar HBM bandwidth will not decode $2\times$ faster.</p>

<p><strong>HBM bandwidth matters, but access patterns matter more.</strong> Coalesced sequential access achieves near-peak bandwidth. Random or strided access may achieve only 30--50\% of peak.</p>

<p><strong>Interconnect latency dominates decode TP performance.</strong> During decode, all-reduce messages are tiny ($\sim$16~KB). A $2\times$ higher-bandwidth interconnect with the same latency provides zero decode benefit.</p>

<p><strong>Software stack maturity can outweigh raw specs.</strong> A chip with inferior specs but a mature, optimized software stack often outperforms a faster chip with immature software.</p>

<h3>Workload-to-Hardware Fit</h3>

<table>
<tr><th><strong>Workload Profile</strong></th><th><strong>Key Hardware Dimension</strong></th><th><strong>Why</strong></th></tr>
<tr><td>Decode-heavy, low-latency</td><td>Interconnect latency + HBM BW</td><td>Weight loading + AR latency dominate</td></tr>
<tr><td>Long-context, high-concurrency</td><td>HBM capacity + KV strategy</td><td>KV-cache dominates memory</td></tr>
<tr><td>Prefill-heavy, batch throughput</td><td>Compute TFLOPS + HBM BW</td><td>Large GEMMs are compute-bound</td></tr>
<tr><td>MoE with EP</td><td>Bisection bandwidth + topology</td><td>All-to-all needs every device to talk</td></tr>
</table>

<h2>Quantization: Precision, Performance, and Trade-offs</h2>

<h3>Quantization Taxonomy</h3>

<p>Quantization means using fewer bits to represent numbers. Standard transformer inference uses BF16 (2 bytes per number). Quantization reduces this to 8 bits (FP8 or INT8, 1 byte) or even 4 bits (INT4, 0.5 bytes). Three potential benefits: less memory used, less data to move, and more operations per clock cycle.</p>

<p>Crucially, quantization is not one technique---it is a family targeting different tensors:</p>

<p><strong>Weight quantization (GPTQ, AWQ, GGML):</strong> reduces weight memory footprint. Decode benefits most: less data to load from HBM per token. Does NOT reduce communication volume because activations being all-reduced remain at higher precision.</p>

<p><strong>Activation quantization (FP8 compute):</strong> uses FP8 for the actual matrix multiplication. Benefits both compute throughput ($2\times$ TFLOPS on FP8-capable hardware) and communication volume. Most impactful for prefill because prefill is compute-bound.</p>

<p><strong>KV-cache quantization (INT8/FP8 KV):</strong> stores KV vectors at lower precision. Cuts KV memory per token in half, enabling more concurrent requests or longer contexts.</p>

<p><strong>Communication precision:</strong> running all-reduce at FP8 instead of BF16 halves data volume. Most relevant during prefill where messages are large.</p>

<h3>Quantization Fundamentals</h3>

<div class="definition"><strong>Definition:</strong> 
Map floating-point weights to lower precision:
<div class="equation">
$$
w_{\text{quant}} = \text{round}\left(\frac{w_{\text{float}}}{s}\right) + z
$$
</div>
where $s$ is the scale factor and $z$ is the zero-point.
</div>

<div class="example"><strong>Example:</strong> 
<strong>FP32 weight:</strong> $w = 0.137$. <strong>Range:</strong> $w \in [-1.0, 1.0]$. <strong>Scale:</strong> $s = 2.0/256 = 0.0078125$.

<p><strong>Quantize:</strong>
<div class="equation">
$$
w_{\text{INT8}} = \text{round}\left(\frac{0.137}{0.0078125}\right) = \text{round}(17.54) = 18
$$
</div>

<p><strong>Dequantize:</strong> $w' = 18 \times 0.0078125 = 0.1406$. <strong>Error:</strong> $|0.137 - 0.1406| = 0.0036$ (2.6\% relative).
</div>

<h3>Post-Training Quantization (PTQ)</h3>

<p>PTQ takes a fully trained FP32 model and converts it to lower precision through a calibration process. A small calibration dataset (a few hundred to a few thousand examples) is processed in FP32 while collecting activation statistics. These statistics determine scale factors mapping the continuous FP32 range to the discrete INT8 range.</p>

<p>The primary advantage is simplicity: no retraining required. Modern frameworks provide built-in PTQ APIs. The limitation: quantization errors accumulate through deep networks. Layers with wide activation distributions or outlier values are especially sensitive.</p>

<h3>Quantization-Aware Training (QAT)</h3>

<p>QAT incorporates quantization effects directly into training. In the forward pass, weights and activations are quantized to the target precision using the same formula as inference. The backward pass operates in full FP32 precision. This allows the optimizer to adjust weights to positions robust to rounding and learn activation distributions that quantize well.</p>

<div class="example"><strong>Example:</strong> 
<div style="text-align: center;">

<table>
<tr><th><strong>Precision</strong></th><th><strong>GLUE Score</strong></th><th><strong>Speedup</strong></th></tr>
<tr><td>FP32 (baseline)</td><td>84.5</td><td>$1.0\times$</td></tr>
<tr><td>FP16</td><td>84.4</td><td>$1.8\times$</td></tr>
<tr><td>INT8 (PTQ)</td><td>82.1</td><td>$2.9\times$</td></tr>
<tr><td>INT8 (QAT)</td><td>84.2</td><td>$2.9\times$</td></tr>
</table>

<p></div>
QAT recovers most accuracy lost in PTQ while maintaining the same speedup.
</div>

<h3>Accuracy and Stability Trade-offs</h3>

<p><strong>Calibration:</strong> FP8 and INT8 require scaling factors derived from representative data. Poor calibration clips important values.</p>

<p><strong>Outlier sensitivity:</strong> some models have occasional very large activation values critical for quality. Techniques like SmoothQuant redistribute outlier magnitude from activations to weights before quantizing.</p>

<p><strong>Accumulation precision:</strong> FP8 multiply with FP32 accumulate is generally safe; FP8 accumulate can cause compounding rounding errors.</p>

<p><strong>Model-specific:</strong> some architectures (e.g., Llama family) tolerate FP8 well. Others show noticeable quality regression. Always evaluate on your specific model and task.</p>

<h3>Quantization Decision Heuristics</h3>

<table>
<tr><th><strong>Bottleneck</strong></th><th><strong>Strategy</strong></th><th><strong>Why</strong></th></tr>
<tr><td>Memory capacity (weights)</td><td>Weight-only quant (INT4/INT8)</td><td>Reduces weight memory directly</td></tr>
<tr><td>Memory capacity (KV-cache)</td><td>KV quantization (INT8/FP8)</td><td>Frees memory for more requests</td></tr>
<tr><td>Compute throughput (prefill)</td><td>FP8 activation + compute</td><td>$2\times$ TFLOPS on FP8 hardware</td></tr>
<tr><td>TP communication (BW-bound)</td><td>FP8 communication</td><td>Halves all-reduce volume</td></tr>
<tr><td>Quality-sensitive</td><td>Start BF16, add conservatively</td><td>Measure regression first</td></tr>
</table>

<h2>Model Pruning</h2>

<h3>Pruning Strategies</h3>

<p>Model pruning removes parameters to reduce computational and memory requirements. Two main approaches exist:</p>

<p><strong>Magnitude-based pruning</strong> removes weights with small absolute values: if $|w_{ij}| < \tau$, the weight is set to zero. The threshold $\tau$ can be set globally, per-layer, or adaptively.</p>

<p><strong>Structured vs.\ unstructured pruning.</strong> Unstructured pruning removes individual weights, creating sparse matrices that require specialized sparse kernels to realize speedups. Structured pruning removes entire architectural units (neurons, attention heads, layers), directly reducing matrix dimensions visible to standard dense libraries. Structured pruning achieves lower compression ratios but provides immediate speedups without custom kernels.</p>

<h3>Iterative Pruning</h3>

<div class="algorithm"><div class="algorithm-title">Algorithm: Iterative Magnitude Pruning</div>
<div class="algorithm-line"><strong>Input:</strong> Model, sparsity target $s_{\text{target}}$</div>
<div class="algorithm-line"><p>\For{sparsity $s = 0$ \KwTo $s_{\text{target}}$ by steps}{</div>
<div class="algorithm-line">Train model to convergence</div>
<div class="algorithm-line">Prune $\Delta s$ lowest-magnitude weights</div>
<div class="algorithm-line">Fine-tune model</div>
</div>

<div class="example"><strong>Example:</strong> 
BERT-base: 12 layers $\times$ 12 heads $=$ 144 heads.

<p><strong>Finding:</strong> Can remove 50\% of heads with minimal impact.</p>

<p><strong>Procedure:</strong> (1) Compute importance score per head. (2) Rank by importance. (3) Prune lowest 50\% (72 heads). (4) Fine-tune.</p>

<p><strong>Result:</strong> 50\% fewer attention operations. GLUE score: $84.5 \to 83.8$ (0.7 point drop). $1.5\times$ faster inference.
</div>

<h2>Knowledge Distillation</h2>

<div class="definition"><strong>Definition:</strong> 
<div class="equation">
$$
\mathcal{L} = \alpha \mathcal{L}_{\text{CE}}(y, y_{\text{student}}) + (1-\alpha) \mathcal{L}_{\text{KD}}(y_{\text{teacher}}, y_{\text{student}})
$$
</div>
where:
<div class="equation">
$$
\mathcal{L}_{\text{KD}} = \text{KL}\left(\frac{\exp(z_t/T)}{\sum \exp(z_t/T)} \Big\| \frac{\exp(z_s/T)}{\sum \exp(z_s/T)}\right)
$$
</div>
$T$ = temperature (typically 2--5), higher = softer probabilities.
</div>

<h3>DistilBERT Approach</h3>

<p>DistilBERT reduces depth by half (6 layers vs.\ BERT-base's 12) while maintaining hidden size 768. The student is initialized by copying every other layer from the teacher. Training combines three losses: distillation loss (match teacher's output distribution), masked language modeling loss, and cosine distance loss between hidden states.</p>

<p><strong>Results:</strong> 66M parameters (vs.\ 110M), $\sim$60\% faster inference, retains 97\% of BERT's GLUE performance. This combination of compression, speedup, and accuracy retention makes DistilBERT compelling for production deployments.</p>

<h2>Bottleneck-Driven Optimization</h2>

<p>Do not apply optimizations by popularity. Apply them by bottleneck. A $10\times$ kernel speedup is worthless if the bottleneck is scheduling overhead. A perfect scheduler is worthless if the bottleneck is interconnect latency. The single most important skill in inference optimization is correctly identifying where time is actually being spent.</p>

<h3>Bottleneck Taxonomy</h3>

<p>Every inference workload is dominated by one (occasionally two) bottleneck regimes. Identifying the regime tells you which family of optimizations will help:</p>

<table>
<tr><th><strong>Bottleneck Regime</strong></th><th><strong>Symptom</strong></th><th><strong>Dominant In</strong></th></tr>
<tr><td>Compute-bound</td><td>Utilization $>$85\%; more batch doesn't help</td><td>Prefill with large batches</td></tr>
<tr><td>HBM bandwidth-bound</td><td>Low utilization despite available work</td><td>Decode (single-token GEMMs)</td></tr>
<tr><td>Interconnect BW-bound</td><td>Large collective messages, high link utilization</td><td>Prefill TP all-reduce, EP a2a</td></tr>
<tr><td>Interconnect latency-bound</td><td>Small messages, latency dominates</td><td>Decode TP all-reduce</td></tr>
<tr><td>Host/runtime overhead-bound</td><td>Low utilization, dispatch visible in profile</td><td>Decode without graph replay</td></tr>
<tr><td>Memory capacity-bound</td><td>OOM or aggressive KV eviction</td><td>Long context + high concurrency</td></tr>
<tr><td>Scheduler/policy-bound</td><td>Low utilization despite available requests</td><td>Bursty traffic, poor scheduling</td></tr>
</table>

<h3>Diagnosis Workflow</h3>

<p>A systematic approach to optimization:</p>

<ol>
    <li><strong>Define the target metric.</strong> Latency (TTFT, ITL, P50, P99)? Throughput (tokens/s)? Cost (tokens/dollar)?
    <li><strong>Segment the workload.</strong> What fraction is prefill vs.\ decode? What is the sequence length distribution?
    <li><strong>Profile.</strong> Use vendor profilers (Nsight, rocprof, XLA profiler, Neuron profiler) to measure host time, kernel time, communication time, idle time, memory utilization.
    <li><strong>Classify the bottleneck.</strong> Match profiler signals to the taxonomy above.
    <li><strong>Choose the optimization family.</strong> Compute-bound $\to$ FP8, kernel optimization. BW-bound $\to$ quantization, memory access optimization. Latency-bound $\to$ graph replay, custom collectives. Overhead-bound $\to$ compilation, better scheduling. Capacity-bound $\to$ quantization, KV optimization, more devices.
    <li><strong>Re-measure.</strong> Verify the optimization helped end-to-end. A local improvement that shifts the bottleneck elsewhere may show no system-level gain.
</ol>

<h3>Optimization Impact Summary</h3>

<table>
<tr><th><strong>Optimization</strong></th><th><strong>Layer</strong></th><th><strong>Gain</strong></th><th><strong>Bottleneck Relieved</strong></th><th><strong>Helps</strong></th><th><strong>Trade-off</strong></th></tr>
<tr><td><code>torch.compile</code>/XLA</td><td>5</td><td>1.5--3$\times$</td><td>Host overhead</td><td>Decode $>$ prefill</td><td>Compile time; graph breaks</td></tr>
<tr><td>FlashAttention</td><td>3</td><td>2--4$\times$ attn</td><td>HBM BW (attention)</td><td>Prefill $>$ decode</td><td>Kernel compatibility</td></tr>
<tr><td>Continuous batching</td><td>4</td><td>3--8$\times$ tput</td><td>Scheduler/utilization</td><td>Both</td><td>Tail latency risk</td></tr>
<tr><td>PagedAttention</td><td>4</td><td>2--4$\times$ concurrency</td><td>Memory capacity (KV)</td><td>Both</td><td>Indirection overhead</td></tr>
<tr><td>Fused GEMM+AllReduce</td><td>3</td><td>1.3--1.8$\times$ TP</td><td>Interconnect (TP path)</td><td>Prefill $>$ decode</td><td>Kernel complexity</td></tr>
<tr><td>FP8 compute</td><td>3+1</td><td>1.5--2$\times$</td><td>Compute + HBM BW</td><td>Prefill $>$ decode</td><td>Accuracy risk</td></tr>
<tr><td>Graph replay</td><td>2</td><td>1.2--2$\times$ decode</td><td>Host overhead</td><td>Decode $\gg$ prefill</td><td>Static shape requirement</td></tr>
</table>

<h3>Case Study: Interactive Chatbot (Decode-Heavy)</h3>

<p>Target: P50 inter-token latency $< 30$~ms. 70B model on 8$\times$H100. Decode dominates because each response generates hundreds of tokens.</p>

<p><strong>Bottleneck analysis:</strong> per-token GEMMs are memory-bandwidth-bound. TP all-reduce is latency-bound (16~KB messages). Host dispatch overhead is significant without graph replay.</p>

<p><strong>Priority 1 (Layer~4):</strong> continuous batching with moderate batch sizes (8--32).</p>

<p><strong>Priority 2 (Layers~5/2):</strong> graph compilation + CUDA Graph replay for decode.</p>

<p><strong>Priority 3 (Layer~3):</strong> custom small-message all-reduce bypassing NCCL overhead.</p>

<p><strong>Priority 4 (Layer~7):</strong> TP-4 rather than TP-8. Each additional TP degree adds serialized all-reduce latency per token.</p>

<h3>Case Study: Batch Document Summarization (Prefill-Heavy)</h3>

<p>Target: maximize tokens/second/dollar. 70B model on 8$\times$H100. Processing thousands of long documents offline.</p>

<p><strong>Bottleneck analysis:</strong> large GEMMs are compute-bound. TP all-reduce messages are large (bandwidth-relevant). Memory capacity constrains batch size.</p>

<p><strong>Priority 1 (Layer~4):</strong> continuous batching with large batches (128--512).</p>

<p><strong>Priority 2 (Layer~3):</strong> FP8 GEMMs. $2\times$ compute throughput maps directly to $\sim$$2\times$ prefill throughput.</p>

<p><strong>Priority 3 (Layer~3):</strong> fused GEMM+all-reduce. Large prefill GEMMs provide enough compute time to overlap communication.</p>

<p><strong>Priority 4:</strong> KV-cache quantization (FP8 KV) to free memory for more concurrent documents.</p>

<h2>Production Deployment</h2>

<h3>Serving Frameworks</h3>

<p><strong>TorchServe</strong> provides native PyTorch serving with REST/gRPC APIs, dynamic batching, model versioning, and integrated monitoring. Natural deployment path for PyTorch-trained models.</p>

<p><strong>Triton Inference Server</strong> supports models from PyTorch, TensorFlow, ONNX, and TensorRT within a single infrastructure. Sophisticated scheduling can execute multiple models concurrently on the same GPU.</p>

<p><strong>ONNX Runtime</strong> provides framework-agnostic inference with graph-level optimizations (operator fusion, constant folding, dead code elimination). Typically delivers 1.5--2$\times$ speedup over PyTorch inference; combined with INT8 quantization, 3--4$\times$. See Chapter~[ref] for ONNX export code.</p>

<p><strong>TensorRT</strong> leverages detailed knowledge of NVIDIA GPU architectures for aggressive layer fusion, kernel auto-tuning, and INT8 calibration. For BERT-base: 2--3$\times$ speedup over PyTorch in FP16; 4--5$\times$ with INT8.</p>

<h3>Distributed Inference with Ray and Kubernetes</h3>

<p>When inference workloads exceed single-machine capacity, they are typically deployed on a Kubernetes cluster with Ray Serve handling request routing and autoscaling. A Ray cluster runs inside Kubernetes: a head pod manages state, worker pods host GPU-backed model replicas. Kubernetes provisions and recovers pods; Ray's autoscaler adjusts replica count based on request rate and queue length.</p>

<p>Designing such a system requires coordinating multiple scaling layers. Each replica needs appropriate concurrency limits and batch sizes to avoid GPU memory oversubscription. Ray's autoscaler must react quickly to sustained load without oscillations. Kubernetes node autoscaling must align with Ray's resource requests. Observability across all layers is essential for diagnosing stalled scaling, replica imbalance, or OOM events.</p>

<h3>Deployment Checklist</h3>

<p><strong>Performance optimization:</strong> quantize to INT8/FP16 where accuracy permits; export to ONNX/TensorRT for graph-level optimization; tune batch size for latency--throughput balance; enable KV caching for autoregressive generation.</p>

<p><strong>Reliability engineering:</strong> distinguish transient vs.\ permanent failures with appropriate retry logic; set request timeouts; implement health checks for load balancer integration; enable model versioning for safe rollouts.</p>

<p><strong>Monitoring and observability:</strong> track latency at p50/p95/p99 (not just averages); measure throughput in requests/second; monitor GPU utilization to identify headroom; break down error rates by type.</p>

<h3>Hardware Selection</h3>

<h4>CPU vs.\ GPU Trade-offs</h4>

<p>CPUs suit small models ($<$100M parameters) with batch size 1--4 and latency-critical single-request scenarios. A distilled BERT (66M parameters) achieves 15~ms latency on modern CPU with batch size 1.</p>

<p>GPUs become the clear choice for training (any size), large models ($>$100M), batch inference (batch $>$ 8), and throughput-oriented applications. BERT-large achieves 2.5 seq/s on CPU vs.\ 45 seq/s on T4 GPU ($18\times$ advantage).</p>

<p>Cost analysis often favors GPUs despite higher instance cost: T4 GPU at \$0.35/hour processes 162K sequences/hour (\$0.0000022/seq) vs.\ CPU at \$0.10/hour processing 9K sequences/hour (\$0.000011/seq)---GPU is $5\times$ more cost-effective.</p>

<h4>Training Hardware Selection</h4>

<ul>
    <li><strong>$<$1B parameters:</strong> single V100 or A100. BERT-base trains in $\sim$3 days on V100.
    <li><strong>1--10B parameters:</strong> 4--8 A100 GPUs with NVLink. GPT-2 (1.5B) trains in $\sim$2 weeks on 8$\times$A100.
    <li><strong>10--100B parameters:</strong> 16--64 A100 GPUs with NVLink + InfiniBand. Requires pipeline and tensor parallelism.
    <li><strong>$>$100B parameters:</strong> hundreds to thousands of GPUs. Training costs reach millions of dollars.
</ul>

<h4>Inference Hardware Selection</h4>

<ul>
    <li><strong>Batch throughput:</strong> A100 or A10 GPUs with large batches (32--128). BERT-large: 520 seq/s on A100 with batch 64.
    <li><strong>Low-latency:</strong> T4 or A10 with TensorRT + INT8. BERT-base: 5~ms latency on T4 with batch 1.
    <li><strong>Cost-optimized:</strong> CPU or T4 with quantized models. Distilled BERT on CPU: $\sim$\$0.000005/inference.
    <li><strong>Edge:</strong> mobile CPUs, edge TPUs, Jetson. MobileBERT (25M params): 30~ms on mobile CPU.
</ul>

<h2>Key Takeaways and Engineering Decision Checklist</h2>

<h3>Principles</h3>

<p><strong>1. Parallelism at Layer~7 is typically the most consequential decision.</strong> It determines communication patterns, memory distribution, and constraints on every layer below.</p>

<p><strong>2. The top of the stack is portable.</strong> Layers 7--5 work across vendors. Invest in understanding these first.</p>

<p><strong>3. Layers~4 and~3 often deliver the largest end-to-end gains.</strong> Inference engine optimizations and custom kernels provide the biggest multipliers, but only after parallelism and compilation are correctly configured.</p>

<p><strong>4. Communication follows the Bandwidth Ladder.</strong> TP on fastest link, PP tolerates slower links, EP needs bisection bandwidth.</p>

<p><strong>5. Diagnose before optimizing.</strong> Profile to classify the bottleneck regime. Apply the optimization family that addresses that regime. Re-measure.</p>

<p><strong>6. Numbers require context.</strong> Every speedup claim is scoped to a workload phase, hardware configuration, and software version.</p>

<h3>Engineering Decision Checklist</h3>

<ol>
    <li>What is the objective metric? Latency (TTFT, ITL)? Throughput (tokens/s)? Cost (tokens/dollar)?
    <li>Is the workload prefill- or decode-dominated?
    <li>What is the bottleneck regime? Profile first.
    <li>Is parallelism required for fit or chosen for performance?
    <li>Is shape regularity sufficient for graph replay? If not, implement bucketing.
    <li>Is the interconnect appropriate for TP/EP?
    <li>What precision trade-off is acceptable? Measure accuracy impact before committing.
    <li>Does the optimization help end-to-end? Always measure the system-level metric.
</ol>

<h2>Worked End-to-End Token Trace</h2>

<p>One complete decode step for a 70B model on TP-4 (4$\times$H100, NVSwitch). BF16. $B=16$ concurrent requests.</p>

<table>
<tr><th><strong>\#</strong></th><th><strong>Layer</strong></th><th><strong>What Happens</strong></th><th><strong>Time (illustrative)</strong></th><th><strong>Bottleneck</strong></th></tr>
<tr><td>1</td><td>4: Scheduler</td><td>Select batch of 16 reqs, allocate KV pages</td><td>$\sim$10--50~$\mu$s</td><td>Host overhead</td></tr>
<tr><td>2</td><td>5/2: Replay</td><td>Launch compiled decode graph for $[B\!=\!16,S\!=\!1]$</td><td>$\sim$5--10~$\mu$s</td><td>Host overhead</td></tr>
<tr><td>3</td><td>3: GEMM</td><td>QKV projection (column-parallel)</td><td>$\sim$15--30~$\mu$s</td><td>HBM BW-bound</td></tr>
<tr><td>4</td><td>3: Attention</td><td>FlashAttention: 8 local heads, KV-cache lookup</td><td>$\sim$10--40~$\mu$s</td><td>HBM BW-bound</td></tr>
<tr><td>5</td><td>3: GEMM+AR</td><td>Output proj (row-par) + all-reduce 256~KB</td><td>$\sim$15--30 + 2--5~$\mu$s</td><td>HBM BW + latency</td></tr>
<tr><td>6</td><td>3: FFN</td><td>Gate+Up (col-par), SwiGLU, Down (row-par) + AR</td><td>$\sim$30--60 + 2--5~$\mu$s</td><td>HBM BW-bound</td></tr>
<tr><td>7</td><td>Repeat</td><td>$\times$80 layers</td><td>$\sim$5--15~ms total</td><td>Accumulated</td></tr>
<tr><td>8</td><td>4: Complete</td><td>Detokenize, check stop, reclaim KV</td><td>$\sim$5--20~$\mu$s</td><td>Host overhead</td></tr>
</table>

<h2>Exercises</h2>

<div class="exercise" id="exercise-1"><strong>Exercise 1:</strong> Quantize BERT-base to INT8:
<ol>
    <li>Use PyTorch quantization APIs
    <li>Calibrate on 1000 examples
    <li>Measure: (a) Model size, (b) Inference speed, (c) GLUE accuracy
    <li>Compare PTQ vs QAT
</ol>
</div>

<div class="exercise" id="exercise-2"><strong>Exercise 2:</strong> Implement attention head pruning:
<ol>
    <li>Compute importance scores for all heads
    <li>Prune 25\%, 50\%, 75\% of heads
    <li>Fine-tune after pruning
    <li>Plot accuracy vs sparsity
</ol>
</div>

<div class="exercise" id="exercise-3"><strong>Exercise 3:</strong> Optimize inference pipeline:
<ol>
    <li>Baseline: PyTorch FP32
    <li>Convert to ONNX, measure speedup
    <li>Apply INT8 quantization
    <li>Implement dynamic batching
    <li>Report final throughput improvement
</ol>
</div>

<div class="exercise" id="exercise-4"><strong>Exercise 4:</strong> Analyze the prefill vs.\ decode asymmetry:
<ol>
    <li>For a model with $H=4096$ and 32 layers, compute the arithmetic intensity of a single-token decode GEMM and a 512-token prefill GEMM
    <li>Determine whether each is compute-bound or memory-bound on an H100 (3.35~TB/s, 990~TFLOPS)
    <li>Calculate the theoretical speedup from switching to FP8 ($2\times$ TFLOPS) for each phase
    <li>Explain why the speedup differs between phases
</ol>
</div>

<div class="exercise" id="exercise-5"><strong>Exercise 5:</strong> Tensor parallelism communication analysis:
<ol>
    <li>For a 70B model with $H=8192$ and 80 layers, calculate the total all-reduce data volume per decode token with TP-4 in BF16
    <li>Calculate the communication time assuming NVLink latency of 2~$\mu$s per all-reduce
    <li>Repeat for InfiniBand at 8~$\mu$s per all-reduce
    <li>If decode compute takes 10~ms per token, what percentage overhead does communication add in each case?
    <li>At what TP degree does InfiniBand communication overhead exceed 50\% of compute time?
</ol>
</div>

<div class="exercise" id="exercise-6"><strong>Exercise 6:</strong> Flash Attention implementation study:
<ol>
    <li>Implement standard attention with separate kernels
    <li>Analyze memory traffic for different sequence lengths
    <li>Study Flash Attention paper and implementation
    <li>Benchmark Flash Attention vs standard attention
    <li>Plot speedup as a function of sequence length
</ol>
</div>

<div class="exercise" id="exercise-7"><strong>Exercise 7:</strong> Inference engine configuration:
<ol>
    <li>Deploy a 7B model using vLLM with default settings
    <li>Measure throughput and P50/P99 latency under load
    <li>Experiment with max batch size: 1, 8, 32, 128
    <li>Enable PagedAttention and measure memory utilization improvement
    <li>Compare static batching vs.\ continuous batching throughput
    <li>Identify the bottleneck regime at each batch size using profiling
</ol>
</div>

<div class="exercise" id="exercise-8"><strong>Exercise 8:</strong> Bottleneck diagnosis:
<ol>
    <li>Choose a transformer model and deployment scenario (interactive chatbot or batch processing)
    <li>Profile the deployment using available tools
    <li>Classify the bottleneck using the taxonomy in Table~[ref]
    <li>Select and apply the appropriate optimization from Table~[ref]
    <li>Measure end-to-end improvement and verify the bottleneck shifted
    <li>Document the before/after metrics and explain why the optimization helped
</ol>
</div>

<div class="exercise" id="exercise-9"><strong>Exercise 9:</strong> Hardware selection analysis:
<ol>
    <li>Choose a transformer model and deployment scenario
    <li>Estimate throughput requirements and latency constraints
    <li>Compare cost per inference for CPU, T4, and A100
    <li>Calculate break-even point where GPU becomes cost-effective
    <li>Recommend hardware configuration with justification
</ol>
</div>

<h2>Solutions</h2>

<p>Full solutions for all exercises are available at \url{https://deeplearning.hofkensvermeulen.be}.</p>

<div class="solution"><strong>Solution:</strong> <strong>Exercise 1: Quantize BERT-base to INT8</strong>

<p><strong>Results:</strong></p>

<table>
<tr><th><strong>Method</strong></th><th><strong>Size (MB)</strong></th><th><strong>Speed (ms)</strong></th><th><strong>GLUE Acc</strong></th></tr>
<tr><td>FP32 Baseline</td><td>438</td><td>45.2</td><td>84.5\%</td></tr>
<tr><td>PTQ INT8</td><td>110</td><td>18.3</td><td>83.8\%</td></tr>
<tr><td>QAT INT8</td><td>110</td><td>18.1</td><td>84.2\%</td></tr>
</table>

<p><strong>Analysis:</strong> $4\times$ size reduction (438~MB $\to$ 110~MB). $2.5\times$ faster inference. PTQ: 0.7\% accuracy drop, no retraining. QAT: 0.3\% drop, requires fine-tuning. <strong>Recommendation:</strong> QAT for production.
</div>

<div class="solution"><strong>Solution:</strong> <strong>Exercise 2: Attention Head Pruning</strong>

<table>
<tr><th><strong>Pruning \%</strong></th><th><strong>Params Remaining</strong></th><th><strong>Accuracy</strong></th></tr>
<tr><td>0\% (baseline)</td><td>110M</td><td>84.5\%</td></tr>
<tr><td>25\%</td><td>82.5M</td><td>84.1\%</td></tr>
<tr><td>50\%</td><td>55M</td><td>82.8\%</td></tr>
<tr><td>75\%</td><td>27.5M</td><td>78.3\%</td></tr>
</table>

<p><strong>Key Insight:</strong> Can prune 25--50\% of heads with minimal accuracy loss ($<$2\%), but 75\% causes significant degradation.
</div>

<div class="solution"><strong>Solution:</strong> <strong>Exercise 3: Optimize Inference Pipeline</strong>

<table>
<tr><th><strong>Stage</strong></th><th><strong>Latency (ms)</strong></th><th><strong>Throughput (samples/s)</strong></th></tr>
<tr><td>PyTorch FP32</td><td>45.2</td><td>22.1</td></tr>
<tr><td>+ ONNX</td><td>32.8</td><td>30.5</td></tr>
<tr><td>+ INT8 Quant</td><td>14.7</td><td>68.0</td></tr>
<tr><td>+ Dynamic Batch</td><td>12.3</td><td>162.4</td></tr>
</table>

<p><strong>Final Improvement:</strong> $7.3\times$ throughput increase ($22.1 \to 162.4$ samples/s).
</div>

<div class="solution"><strong>Solution:</strong> <strong>Exercise 4: Prefill vs.\ Decode Asymmetry</strong>

<p>For $H=4096$, weight matrix $[4096 \times 4096]$, size $= 4096^2 \times 2 = 32$~MB.</p>

<p><strong>Decode</strong> ($B=1$): FLOPs $= 2 \times 4096^2 = 33.6$M. Intensity $= 33.6\text{M} / 32\text{M} \approx 1$ FLOP/byte. H100 balance point: $990\text{T}/3.35\text{T} = 295$ FLOPs/byte. Decode is deeply memory-bound.</p>

<p><strong>Prefill</strong> ($B=512$): FLOPs $= 2 \times 512 \times 4096^2 = 17.2$B. Intensity $= 17.2\text{B}/32\text{M} = 537$ FLOPs/byte. Prefill is compute-bound.</p>

<p>FP8 ($2\times$ TFLOPS): prefill speedup $\approx 1.8\times$ (compute-bound, nearly doubles). Decode speedup $\approx 1.0\times$ (bandwidth-bound, TFLOPS irrelevant). The asymmetry arises because decode's bottleneck is loading weights from HBM, not computing with them.
</div>

<div class="solution"><strong>Solution:</strong> <strong>Exercise 5: TP Communication Analysis</strong>

<p>Per all-reduce: $H \times p = 8192 \times 2 = 16$~KB. Per layer: $2 \times 16 = 32$~KB. For 80 layers: $80 \times 32 = 2560$~KB $\approx 2.5$~MB total. Number of all-reduces: $80 \times 2 = 160$.</p>

<p><strong>NVLink</strong> ($2~\mu$s/AR): $160 \times 2 = 320~\mu$s. Overhead: $320~\mu\text{s} / 10~\text{ms} = 3.2\%$.</p>

<p><strong>InfiniBand</strong> ($8~\mu$s/AR): $160 \times 8 = 1280~\mu$s. Overhead: $1280~\mu\text{s} / 10~\text{ms} = 12.8\%$.</p>

<p>For 50\% overhead on IB: $160 \times 8 \times \text{TP} = 5000~\mu$s requires TP $\approx 4$ (since overhead scales with TP degree through additional synchronization points). This demonstrates why TP must use the fastest available link.
</div>

<div class="solution"><strong>Solution:</strong> <strong>Exercise 7: Inference Engine Configuration</strong>

<p>Representative results for a 7B model on a single A100:</p>

<table>
<tr><th><strong>Config</strong></th><th><strong>Batch</strong></th><th><strong>Tput (tok/s)</strong></th><th><strong>P50 (ms)</strong></th><th><strong>P99 (ms)</strong></th></tr>
<tr><td>Static, no paging</td><td>1</td><td>42</td><td>24</td><td>31</td></tr>
<tr><td>vLLM, batch=8</td><td>8</td><td>285</td><td>28</td><td>45</td></tr>
<tr><td>vLLM, batch=32</td><td>32</td><td>890</td><td>36</td><td>72</td></tr>
<tr><td>vLLM, batch=128</td><td>128</td><td>1,650</td><td>78</td><td>185</td></tr>
</table>

<p><strong>Key findings:</strong> PagedAttention increases effective concurrency by $\sim$$3\times$ vs.\ contiguous allocation. Continuous batching provides $\sim$$4\times$ throughput over static batching at batch=32. At batch=128, the bottleneck shifts from scheduling to HBM bandwidth (decode GEMMs). P99 latency grows faster than P50, indicating tail effects from prefill interference.
</div>

<div class="solution"><strong>Solution:</strong> <strong>Exercise 9: Hardware Selection</strong>

<p><strong>Scenario:</strong> BERT-base inference, 1M requests/day, $<$50~ms latency.</p>

<table>
<tr><th><strong>Hardware</strong></th><th><strong>Throughput</strong></th><th><strong>Cost/hour</strong></th><th><strong>Cost/1M inferences</strong></th></tr>
<tr><td>CPU (32 cores)</td><td>45 req/s</td><td>\$1.20</td><td>\$7.41</td></tr>
<tr><td>T4 GPU</td><td>180 req/s</td><td>\$0.35</td><td>\$0.54</td></tr>
<tr><td>A100 GPU</td><td>650 req/s</td><td>\$2.50</td><td>\$1.07</td></tr>
</table>

<p><strong>Break-even:</strong> T4 becomes cost-effective at $>$10K requests/day. <strong>Recommendation:</strong> T4 GPU (best cost/performance for this workload).
</div>
        
        <div class="chapter-nav">
  <a href="chapter21_pytorch_implementation.html">‚Üê Chapter 21: PyTorch Implementation</a>
  <a href="../../deeptech.html">üìö Table of Contents</a>
  <a href="chapter23_best_practices.html">Chapter 23: Best Practices ‚Üí</a>
</div>

    </main>

    <footer>
        <p>&copy; 2026 Deep Learning and Transformers Textbook. All rights reserved.</p>
    </footer>

    <script src="../js/main.js"></script>
</body>
</html>
