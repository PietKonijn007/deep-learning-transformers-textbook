<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chapter 13: BERT - Deep Learning and Transformers</title>
    <link rel="stylesheet" href="../../styles.css">
    
    <!-- MathJax Configuration (must come before loading MathJax) -->
    <script>
    window.MathJax = {
        tex: {
            inlineMath: [['$', '$'], ['\\(', '\\)']],
            displayMath: [['$$', '$$'], ['\\[', '\\]']],
            processEscapes: true,
            processEnvironments: true,
            tags: 'ams',
            macros: {
                R: '{\\mathbb{R}}',
                N: '{\\mathbb{N}}',
                Z: '{\\mathbb{Z}}',
                C: '{\\mathbb{C}}',
                va: '{\\mathbf{a}}',
                vb: '{\\mathbf{b}}',
                vc: '{\\mathbf{c}}',
                vd: '{\\mathbf{d}}',
                ve: '{\\mathbf{e}}',
                vf: '{\\mathbf{f}}',
                vg: '{\\mathbf{g}}',
                vh: '{\\mathbf{h}}',
                vi: '{\\mathbf{i}}',
                vj: '{\\mathbf{j}}',
                vk: '{\\mathbf{k}}',
                vl: '{\\mathbf{l}}',
                vm: '{\\mathbf{m}}',
                vn: '{\\mathbf{n}}',
                vo: '{\\mathbf{o}}',
                vp: '{\\mathbf{p}}',
                vq: '{\\mathbf{q}}',
                vr: '{\\mathbf{r}}',
                vs: '{\\mathbf{s}}',
                vt: '{\\mathbf{t}}',
                vu: '{\\mathbf{u}}',
                vv: '{\\mathbf{v}}',
                vw: '{\\mathbf{w}}',
                vx: '{\\mathbf{x}}',
                vy: '{\\mathbf{y}}',
                vz: '{\\mathbf{z}}',
                mA: '{\\mathbf{A}}',
                mB: '{\\mathbf{B}}',
                mC: '{\\mathbf{C}}',
                mD: '{\\mathbf{D}}',
                mE: '{\\mathbf{E}}',
                mF: '{\\mathbf{F}}',
                mG: '{\\mathbf{G}}',
                mH: '{\\mathbf{H}}',
                mI: '{\\mathbf{I}}',
                mJ: '{\\mathbf{J}}',
                mK: '{\\mathbf{K}}',
                mL: '{\\mathbf{L}}',
                mM: '{\\mathbf{M}}',
                mN: '{\\mathbf{N}}',
                mO: '{\\mathbf{O}}',
                mP: '{\\mathbf{P}}',
                mQ: '{\\mathbf{Q}}',
                mR: '{\\mathbf{R}}',
                mS: '{\\mathbf{S}}',
                mT: '{\\mathbf{T}}',
                mU: '{\\mathbf{U}}',
                mV: '{\\mathbf{V}}',
                mW: '{\\mathbf{W}}',
                mX: '{\\mathbf{X}}',
                mY: '{\\mathbf{Y}}',
                mZ: '{\\mathbf{Z}}',
                transpose: '{^\\top}',
                norm: ['\\left\\|#1\\right\\|', 1],
                abs: ['\\left|#1\\right|', 1]
            }
        },
        startup: {
            pageReady: () => {
                console.log('MathJax loaded and ready');
                return MathJax.startup.defaultPageReady();
            }
        }
    };
    </script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>
    <nav>
        <a href="../../deeptech.html">üè† Home</a>
        <a href="preface.html">Preface</a>
        <a href="notation.html">Notation</a>
        <a href="chapter01_linear_algebra.html">Ch 1</a>
        <a href="chapter02_calculus_optimization.html">Ch 2</a>
        <a href="chapter03_probability_information.html">Ch 3</a>
        <a href="chapter04_feedforward_networks.html">Ch 4</a>
        <a href="chapter05_convolutional_networks.html">Ch 5</a>
        <a href="chapter06_recurrent_networks.html">Ch 6</a>
        <a href="chapter07_attention_fundamentals.html">Ch 7</a>
        <a href="chapter08_self_attention.html">Ch 8</a>
        <a href="chapter09_attention_variants.html">Ch 9</a>
        <a href="chapter10_transformer_model.html">Ch 10</a>
        <a href="chapter11_training_transformers.html">Ch 11</a>
        <a href="chapter12_computational_analysis.html">Ch 12</a>
        <a href="chapter13_bert.html">Ch 13</a>
        <a href="chapter14_gpt.html">Ch 14</a>
        <a href="chapter15_t5_bart.html">Ch 15</a>
        <a href="chapter16_efficient_transformers.html">Ch 16</a>
        <a href="chapter17_vision_transformers.html">Ch 17</a>
        <a href="chapter18_multimodal_transformers.html">Ch 18</a>
        <a href="chapter19_long_context.html">Ch 19</a>
        <a href="chapter20_pretraining_strategies.html">Ch 20</a>
        <a href="chapter21_pytorch_implementation.html">Ch 21</a>
        <a href="chapter22_hardware_optimization.html">Ch 22</a>
        <a href="chapter23_best_practices.html">Ch 23</a>
        <a href="chapter24_domain_specific_models.html">Ch 24</a>
        <a href="chapter25_enterprise_nlp.html">Ch 25</a>
        <a href="chapter26_code_language.html">Ch 26</a>
        <a href="chapter27_video_visual.html">Ch 27</a>
        <a href="chapter28_knowledge_graphs.html">Ch 28</a>
        <a href="chapter29_recommendations.html">Ch 29</a>
        <a href="chapter30_healthcare.html">Ch 30</a>
        <a href="chapter31_finance.html">Ch 31</a>
        <a href="chapter32_legal.html">Ch 32</a>
        <a href="chapter33_observability.html">Ch 33</a>
        <a href="chapter34_dsl_agents.html">Ch 34</a>
    </nav>

    <main>
        <h1>BERT: Bidirectional Encoder Representations</h1>

<h2>Chapter Overview</h2>

<p>BERT (Bidirectional Encoder Representations from Transformers) revolutionized NLP by introducing effective bidirectional pre-training. This chapter covers BERT's architecture, pre-training objectives (masked language modeling and next sentence prediction), fine-tuning strategies, and variants (RoBERTa, ALBERT, DistilBERT).</p>

<h3>Learning Objectives</h3>

<ol>
    <li>Understand BERT's encoder-only architecture
    <li>Implement masked language modeling (MLM)
    <li>Apply BERT to downstream tasks via fine-tuning
    <li>Compare BERT variants and their improvements
    <li>Analyze BERT's learned representations
    <li>Understand limitations and failure modes
</ol>

<h2>BERT Architecture</h2>

<h3>Model Specification</h3>

<div class="definition"><strong>Definition:</strong> 
BERT is a stack of transformer encoder layers with:
<ul>
    <li><strong>Input:</strong> Token + Segment + Position embeddings
    <li><strong>Processing:</strong> $L$ transformer encoder layers
    <li><strong>Output:</strong> Contextualized representations for all tokens

<div class="architecture-diagram">
<h3>BERT Architecture Data Flow</h3>
<pre class="mermaid">
graph LR
    TOK["[CLS] tok1 [MASK] tok3 [SEP]\n Token IDs in N^n"] -->|"Token Emb\n W_tok in R^V x d"| TE["Token Emb\n in R^n x d"]
    SEG["Segment IDs\n in {0,1}^n"] -->|"Segment Emb\n W_seg in R^2 x d"| SE["Seg Emb\n in R^n x d"]
    POS["Position 0..n-1"] -->|"Pos Emb\n W_pos in R^n_max x d"| PE["Pos Emb\n in R^n x d"]

    TE --> ADD["Sum Embeddings\n E = Tok + Seg + Pos\n in R^n x d\n STORED for backprop"]
    SE --> ADD
    PE --> ADD

    ADD --> ENC["Transformer Encoder\n x L layers (12 or 24)\n Each: MHA + FFN + LN\n STORED per layer:\n attn weights, activations"]

    ENC -->|"[CLS] output"| CLS["CLS repr\n in R^d --> NSP head\n W_nsp in R^d x 2"]
    ENC -->|"masked positions"| MLM["Masked outputs\n in R^k x d --> MLM head\n W_mlm in R^d x V\n STORED for cross-entropy backprop"]

    style TOK fill:#e8f5e9,stroke:#4caf50,color:#000
    style ADD fill:#e3f2fd,stroke:#2196f3,color:#000
    style ENC fill:#fff3e0,stroke:#ff9800,color:#000
    style CLS fill:#f3e5f5,stroke:#9c27b0,color:#000
    style MLM fill:#fce4ec,stroke:#e91e63,color:#000
</pre>
<p class="diagram-caption">BERT Architecture Data Flow</p>
</div>

<p></ul>
</div>

<p>BERT represents a fundamental shift in how we approach natural language understanding by using bidirectional context throughout the entire model. Unlike autoregressive language models such as GPT that can only attend to previous tokens, BERT's encoder-only architecture allows each token to attend to all other tokens in the sequence simultaneously. This bidirectional attention enables BERT to build richer contextual representations that capture both left and right context, making it particularly effective for understanding tasks like question answering, named entity recognition, and text classification.</p>

<p>The architecture comes in two primary configurations that trade off between computational efficiency and model capacity. BERT-base uses 12 transformer encoder layers with hidden dimension $d_{\text{model}} = 768$, employing 12 attention heads where each head operates on dimension $d_k = d_v = 64$. The feed-forward network in each layer expands to dimension $d_{ff} = 3072$, following the standard 4√ó expansion ratio. This configuration contains approximately 110 million parameters and was designed to be trainable on a modest cluster of TPUs while still achieving strong performance across a wide range of tasks.</p>

<p>BERT-large doubles the model depth to 24 layers and increases the hidden dimension to $d_{\text{model}} = 1024$ with 16 attention heads of dimension $d_k = d_v = 64$ each. The feed-forward dimension scales proportionally to $d_{ff} = 4096$, maintaining the 4√ó expansion ratio. With approximately 340 million parameters, BERT-large achieves substantially better performance on challenging tasks but requires significantly more computational resources for both training and inference. The parameter count scales roughly quadratically with hidden dimension due to the $d_{\text{model}}^2$ terms in attention projections and feed-forward networks.</p>

<p><strong>BERT-base specifications:</strong>
<ul>
    <li>Layers: $L = 12$
    <li>Hidden size: $d_{\text{model}} = 768$
    <li>Attention heads: $h = 12$, head dimension: $d_k = d_v = 64$
    <li>Feed-forward size: $d_{ff} = 3072$
    <li>Maximum sequence length: $n_{\max} = 512$
    <li>Vocabulary size: $V \approx 30{,}000$ (WordPiece)
    <li>Total parameters: $\approx 110$M
</ul>

<p><strong>BERT-large specifications:</strong>
<ul>
    <li>Layers: $L = 24$
    <li>Hidden size: $d_{\text{model}} = 1024$
    <li>Attention heads: $h = 16$, head dimension: $d_k = d_v = 64$
    <li>Feed-forward size: $d_{ff} = 4096$
    <li>Maximum sequence length: $n_{\max} = 512$
    <li>Vocabulary size: $V \approx 30{,}000$ (WordPiece)
    <li>Total parameters: $\approx 340$M
</ul>

<h3>Parameter Breakdown and Memory Requirements</h3>

<p>Understanding BERT's parameter distribution is essential for memory planning and optimization. BERT-base totals $\approx$110M parameters: embeddings account for $\sim$21\% ($\sim$23M for token embeddings alone), while the 12 encoder layers contribute $\sim$78\% at 7.1M parameters per layer (see Section~[ref] for the complete worked analysis including FLOPs, activation memory, and hardware timing).</p>

<p>The memory footprint depends critically on numerical precision. In standard FP32 (32-bit floating point), each parameter requires 4 bytes, so BERT-base occupies $110{,}000{,}000 \times 4 = 440$ MB. Modern training typically uses mixed precision with FP16 or BF16 (16-bit formats) for activations and gradients while maintaining FP32 master weights for numerical stability. This reduces the working memory for forward and backward passes to $110{,}000{,}000 \times 2 = 220$ MB for the model parameters, though the optimizer still maintains FP32 copies. For inference, pure FP16 weights require only 220 MB, enabling BERT-base to run comfortably on consumer GPUs with 8-16 GB of memory.</p>

<p>BERT-large's parameter distribution follows the same structure but scales significantly. Token embeddings remain at 23 million parameters (vocabulary size unchanged), but each layer now contains $4 \times 1024^2 = 4{,}194{,}304$ attention parameters and $2 \times 1024 \times 4096 = 8{,}388{,}608$ feed-forward parameters, totaling approximately 12.6 million parameters per layer. With 24 layers, the transformer stack contributes 302 million parameters. The total of 340 million parameters requires 1.36 GB in FP32 or 680 MB in FP16. This larger footprint means BERT-large training typically requires GPUs with at least 16 GB of memory (such as NVIDIA V100 or A100), and inference benefits from GPUs with 12+ GB to accommodate reasonable batch sizes.</p>

<h3>Input Representation</h3>

<div class="equation">
$$
\text{Input} = \text{TokenEmb} + \text{SegmentEmb} + \text{PositionEmb}
$$
</div>

<figure>
<div class="tikz-diagram"><img src="../diagrams/chapter13_bert_6a42bcde44b2.svg" alt="TikZ Diagram" /></div>
<figcaption>BERT's bidirectional encoder architecture. Blue double-headed arrows show that each token can attend to all other tokens in both directions, enabling rich contextual representations. Each output $h_i$ depends on the entire input sequence.</figcaption>
</figure>

<p><strong>Token Embeddings:</strong> WordPiece tokenization, vocabulary $\approx 30{,}000$</p>

<p><strong>Segment Embeddings:</strong> Distinguish sentence A vs B (for sentence-pair tasks)
<div class="equation">
$$
\text{SegEmb}(i) = \begin{cases}
\mathbf{e}_A & \text{if token } i \text{ in sentence A} \\
\mathbf{e}_B & \text{if token } i \text{ in sentence B}
\end{cases}
$$
</div>

<p><strong>Position Embeddings:</strong> Learned absolute positions (not sinusoidal)</p>

<p><strong>Special tokens:</strong>
<ul>
    <li><code>[CLS]</code>: Start of sequence, used for classification
    <li><code>[SEP]</code>: Separate sentences
    <li><code>[MASK]</code>: Masked token for MLM
    <li><code>[PAD]</code>: Padding
</ul>

<div class="example"><strong>Example:</strong> 
Sentence pair: "The cat sat" and "It was tired"

<p><strong>Tokenized:</strong>
<div class="equation">
$$
[<code>[CLS]</code>, \text{The}, \text{cat}, \text{sat}, <code>[SEP]</code>, \text{It}, \text{was}, \text{tired}, <code>[SEP]</code>]
$$
</div>

<p><strong>Segment IDs:</strong>
<div class="equation">
$$
[0, 0, 0, 0, 0, 1, 1, 1, 1]
$$
</div>

<p><strong>Position IDs:</strong>
<div class="equation">
$$
[0, 1, 2, 3, 4, 5, 6, 7, 8]
$$
</div>
</div>

<h2>Pre-Training Objectives</h2>

<h3>Masked Language Modeling (MLM)</h3>

<div class="definition"><strong>Definition:</strong> 
Randomly mask 15\% of tokens and predict them:
<ol>
    <li>Select 15\% of tokens
    <li>Of selected tokens:
    <ul>
        <li>80\%: Replace with <code>[MASK]</code>
        <li>10\%: Replace with random token
        <li>10\%: Keep original
    </ul>
    <li>Predict original tokens
</ol>
</div>

<p>Masked Language Modeling represents BERT's core pre-training objective and the key innovation that enables bidirectional pre-training. Unlike traditional left-to-right language modeling where the model can only condition on previous tokens, MLM randomly masks a subset of input tokens and trains the model to predict the original tokens based on bidirectional context. This approach allows BERT to learn deep bidirectional representations that capture both left and right context simultaneously, which proves crucial for understanding tasks.</p>

<p>The masking strategy employs a carefully designed 80-10-10 split that prevents the model from simply memorizing the training data or developing trivial solutions. When a token is selected for masking (15\% of all tokens), it is replaced with the special <code>[MASK]</code> token 80\% of the time, creating the primary training signal. However, if the model only ever saw <code>[MASK]</code> tokens during training, it would learn to rely exclusively on this special token and fail to generalize during fine-tuning, where <code>[MASK]</code> tokens never appear. To address this mismatch, 10\% of selected tokens are replaced with random tokens from the vocabulary, forcing the model to maintain robust representations even when the input contains noise. The remaining 10\% of selected tokens are kept unchanged, encouraging the model to preserve meaningful representations for all tokens rather than only attending to masked positions.</p>

<p><strong>Objective:</strong>
<div class="equation">
$$
\mathcal{L}_{\text{MLM}} = -\sum_{i \in \mathcal{M}} \log P(x_i | \vx_{\backslash \mathcal{M}})
$$
</div>
where $\mathcal{M}$ is set of masked positions and $\vx_{\backslash \mathcal{M}}$ are unmasked tokens.</p>

<p>The computational cost of MLM is substantial but manageable. For each training example, only 15\% of tokens contribute to the loss, meaning the model must process approximately 6.7 times as many tokens as a standard language model to see the same number of training signals. However, this cost is offset by the ability to process entire sequences in parallel rather than autoregressively. For a sequence of length 512 with 15\% masking, approximately 77 tokens are masked per example. The prediction head for each masked token performs a matrix multiplication with the vocabulary matrix $\mW_{\text{vocab}} \in \R^{d_{\text{model}} \times V}$ followed by softmax over $V \approx 30{,}000$ tokens, requiring $2 \times 77 \times 768 \times 30{,}000 \approx 3.6$ billion FLOPs per example‚Äîa small fraction of the 96.6 billion FLOPs required for the BERT-base forward pass itself.</p>

<div class="example"><strong>Example:</strong> 
Original: "The cat sat on the mat"

<p><strong>Step 1:</strong> Select 15\%: positions 2, 5</p>

<p><strong>Step 2:</strong> Apply masking strategy:
<ul>
    <li>Position 2 ("cat"): Replace with <code>[MASK]</code> (80\% case)
    <li>Position 5 ("the"): Keep original (10\% case)
</ul>

<p><strong>Input:</strong> "The <code>[MASK]</code> sat on the mat"</p>

<p><strong>Targets:</strong> Predict "cat" at position 2, "the" at position 5</p>

<p><strong>Output layer:</strong>
<div class="equation">
$$
\text{logits}_2 = \vh_2 \mW_{\text{vocab}} \quad \text{where } \vh_2 \in \R^{768}
$$
</div>
<div class="equation">
$$
P(\text{token} | \text{position 2}) = \text{softmax}(\text{logits}_2)
$$
</div>
</div>

<p><strong>Why this masking strategy?</strong>
<ul>
    <li>80\% <code>[MASK]</code>: Standard masking
    <li>10\% random: Prevents over-reliance on <code>[MASK]</code> token
    <li>10\% original: Encourages model to maintain representations
</ul>

<h3>Next Sentence Prediction (NSP)</h3>

<div class="definition"><strong>Definition:</strong> 
Binary classification: Does sentence B follow sentence A?
<div class="equation">
$$
P(\text{IsNext} | <code>[CLS]</code>) = \sigma(\mW_{\text{NSP}} \vh_{<code>[CLS]</code>} + \vb_{\text{NSP}})
$$
</div>
</div>

<p><strong>Training data:</strong>
<ul>
    <li>50\%: B actually follows A (label: IsNext)
    <li>50\%: B is random sentence (label: NotNext)
</ul>

<p><strong>NSP Loss:</strong>
<div class="equation">
$$
\mathcal{L}_{\text{NSP}} = -\log P(y_{\text{NSP}} | <code>[CLS]</code>)
$$
</div>

<p><strong>Total pre-training loss:</strong>
<div class="equation">
$$
\mathcal{L} = \mathcal{L}_{\text{MLM}} + \mathcal{L}_{\text{NSP}}
$$
</div>

<div class="keypoint">
Later work (RoBERTa) showed NSP provides minimal benefit. Modern models often use only MLM or variants like span corruption.
</div>

<p>Next Sentence Prediction was introduced as a secondary pre-training objective to help BERT learn relationships between sentence pairs, which is crucial for tasks like question answering and natural language inference. The task takes two sentences A and B, where 50\% of the time B is the actual next sentence that follows A in the corpus, and 50\% of the time B is a random sentence from elsewhere. The model must predict whether B genuinely follows A by using the representation of the special <code>[CLS]</code> token, which is prepended to every input sequence and serves as an aggregate sequence representation.</p>

<p>The motivation for NSP was that many downstream tasks require understanding relationships between sentence pairs, and pre-training on this objective should provide useful inductive biases. However, subsequent research, particularly the RoBERTa paper, demonstrated that NSP provides minimal or even negative benefit to downstream task performance. The likely explanation is that NSP is too easy a task‚Äîthe model can often distinguish random sentences from consecutive sentences based on topic coherence alone, without learning the deeper inter-sentence relationships that would transfer to downstream tasks. RoBERTa removed NSP entirely and instead trained with longer sequences and dynamic masking, achieving substantially better performance. Modern BERT-style models typically omit NSP or replace it with more challenging objectives like sentence order prediction (used in ALBERT) or span corruption (used in T5).</p>

<h2>Training Details and Computational Cost</h2>

<h3>Hardware and Training Configuration</h3>

<p>BERT's original training represents a landmark in demonstrating that large-scale pre-training on commodity hardware clusters could produce models with broad applicability. BERT-base was trained on 16 Cloud TPU v3 chips, where each chip contains 2 cores for a total of 32 TPU cores. However, the paper reports using 4 Cloud TPU v3 Pods with 16 chips each, giving 64 TPU cores total. Each TPU v3 core provides approximately 123 TFLOPS of bfloat16 performance, yielding a combined peak performance of roughly 7.9 PFLOPS for the full training setup. In practice, achieving even 40-50\% utilization on such distributed training is considered excellent, suggesting an effective compute rate of 3-4 PFLOPS during training.</p>

<p>The training configuration uses a batch size of 256 sequences, each of maximum length 512 tokens, for a total of 131,072 tokens per batch. This large batch size is essential for stable training with the Adam optimizer and enables efficient utilization of the TPU hardware, which achieves best performance with large matrix operations. The learning rate schedule employs a warmup phase over the first 10,000 steps where the learning rate increases linearly from 0 to the peak learning rate of $1 \times 10^{-4}$, followed by linear decay to 0 over the remaining training steps. This warmup prevents the large initial gradients from destabilizing training, while the decay helps the model converge to a better optimum.</p>

<p>BERT-base training runs for 1 million steps with this configuration, requiring approximately 4 days of continuous training on the 64 TPU cores. Each training step processes 256 sequences of 512 tokens, so the total training data comprises $1{,}000{,}}000 \times 256 \times 512 = 131$ billion tokens. The training corpus consists of BooksCorpus (800 million words) and English Wikipedia (2.5 billion words), totaling approximately 3.3 billion words or roughly 4.4 billion tokens after WordPiece tokenization. This means the model sees each token approximately 30 times during training, providing sufficient repetition for the model to learn robust representations while maintaining diversity through the random masking strategy.</p>

<h3>Computational Cost Analysis</h3>

<p>The computational cost of BERT pre-training can be estimated from the FLOPs per training step and the total number of steps. As analyzed in Chapter 12, BERT-base requires approximately 96.6 billion FLOPs for a forward pass on a single sequence of length 512. The backward pass requires roughly twice the FLOPs of the forward pass, giving approximately 290 billion FLOPs per training step per sequence. With batch size 256, each training step requires $290 \times 256 = 74.2$ trillion FLOPs. Over 1 million training steps, the total computation is approximately $74.2 \times 10^{15} \times 10^6 = 7.42 \times 10^{22}$ FLOPs, or 74.2 zettaFLOPs.</p>

<p>At an effective compute rate of 3.5 PFLOPS (assuming 45\% utilization of the 7.9 PFLOPS peak), each training step takes approximately $74.2 \times 10^{12} / (3.5 \times 10^{15}) = 21.2$ milliseconds. Over 1 million steps, this yields $21.2 \times 10^6 = 21.2$ million milliseconds, or approximately 5.9 hours of pure compute time. However, the reported 4-day training time includes data loading, checkpointing, and distributed communication overhead, which can easily account for a factor of 16√ó slowdown in practice. This discrepancy highlights the importance of efficient data pipelines and communication strategies in distributed training.</p>

<p>The estimated cost of BERT-base pre-training in 2018 was approximately \$7,000 using Google Cloud TPU pricing. This relatively modest cost (compared to later models like GPT-3, which cost millions of dollars to train) made BERT accessible to academic research groups and smaller companies, democratizing access to large-scale pre-trained models. The cost breaks down to roughly \$1.75 per hour for the TPU Pod configuration, and 4 days of training equals 96 hours, yielding $96 \times \$1.75 \approx \$168$. However, the \$7,000 figure likely includes multiple training runs, hyperparameter tuning, and ablation studies rather than a single successful training run.</p>

<p>BERT-large requires substantially more computation due to its larger size. With 340 million parameters compared to BERT-base's 110 million, and 24 layers instead of 12, BERT-large requires approximately 3-4√ó the FLOPs per training step. The original paper reports training BERT-large for 1 million steps on 64 TPU cores, taking approximately 4 days as well, though this likely involved more aggressive optimization or different batch sizes. The estimated cost for BERT-large pre-training was around \$20,000-\$25,000, reflecting the increased computational requirements.</p>

<h2>Fine-Tuning BERT</h2>

<h3>Fine-Tuning Procedure and Memory Requirements</h3>

<p>Fine-tuning BERT for downstream tasks represents one of the model's key advantages: the pre-trained representations can be adapted to specific tasks with relatively small amounts of labeled data and modest computational resources. The fine-tuning process adds a task-specific head on top of the pre-trained BERT model and trains the entire model end-to-end on the target task. This approach typically requires only 2-4 epochs of training on task-specific data, taking minutes to hours on a single GPU depending on dataset size.</p>

<p>The memory requirements for fine-tuning are substantially lower than pre-training because fine-tuning typically uses smaller batch sizes and shorter sequences. For BERT-base fine-tuning on a classification task with batch size 16 and sequence length 128, the memory breakdown is approximately: 440 MB for model parameters (FP32), 440 MB for gradients, 880 MB for Adam optimizer states, and roughly 2 GB for activations. This totals approximately 3.8 GB, comfortably fitting on consumer GPUs with 8 GB of memory like the RTX 2080 or RTX 3070. Using mixed precision training reduces this to approximately 2.5 GB, enabling batch sizes of 32-48 on the same hardware.</p>

<p>The typical hyperparameter configuration for BERT fine-tuning uses a much smaller learning rate than pre-training to avoid catastrophically forgetting the pre-trained representations. Learning rates in the range of $2 \times 10^{-5}$ to $5 \times 10^{-5}$ work well for most tasks, with a linear warmup over 10\% of training steps followed by linear decay. The batch size typically ranges from 16 to 32 for most tasks, though larger batch sizes (64-128) can improve performance on tasks with abundant training data. Fine-tuning for 2-4 epochs is usually sufficient, as longer training often leads to overfitting on the task-specific data.</p>

<h3>Classification Tasks</h3>

<p>For sequence classification (sentiment, topic, etc.):
<ol>
    <li>Add classification head on <code>[CLS]</code> token
    <div class="equation">
$$
    \text{logits} = \mW_{\text{cls}} \vh_{<code>[CLS]</code>} + \vb_{\text{cls}}
    $$
</div>
    <li>Fine-tune entire model end-to-end
</ol>

<div class="example"><strong>Example:</strong> 
Task: Binary sentiment (positive/negative)

<p><strong>Input:</strong> "This movie was amazing!" $\to$ <code>[CLS]</code> This movie was amazing ! <code>[SEP]</code></p>

<p><strong>BERT encoding:</strong> $\vh_{<code>[CLS]</code>} \in \R^{768}$</p>

<p><strong>Classification head:</strong>
<div class="equation">
$$
\text{logits} = \mW \vh_{<code>[CLS]</code>} + \vb \quad \text{where } \mW \in \R^{2 \times 768}
$$
</div>

<p><strong>Prediction:</strong>
<div class="equation">
$$
P(\text{positive}) = \text{softmax}(\text{logits})_1
$$
</div>

<p><strong>Fine-tuning:</strong> Train on labeled sentiment data for 2-4 epochs with small learning rate ($2 \times 10^{-5}$).
</div>

<h3>Token-Level Tasks</h3>

<p>For named entity recognition (NER), POS tagging:
<ol>
    <li>Add classification head on each token
    <div class="equation">
$$
    \text{logits}_i = \mW_{\text{token}} \vh_i + \vb_{\text{token}}
    $$
</div>
    <li>Predict label for each token independently
</ol>

<h3>Question Answering (SQuAD)</h3>

<p>For span-based QA:
<ol>
    <li>Input: <code>[CLS]</code> Question <code>[SEP]</code> Context <code>[SEP]</code>
    <li>Predict start and end positions in context
    <div class="equation">
$$\begin{align}
    P_{\text{start}}(i) &= \text{softmax}(\vh_i\transpose \mathbf{s}) \\
    P_{\text{end}}(i) &= \text{softmax}(\vh_i\transpose \mathbf{e})
    \end{align}$$
</div>
    where $\mathbf{s}, \mathbf{e} \in \R^{768}$ are learned vectors.
</ol>

<h2>BERT Variants</h2>

<h3>RoBERTa (Robustly Optimized BERT)</h3>

<p>RoBERTa, introduced by Facebook AI Research in 2019, demonstrated that BERT was significantly undertrained and that careful attention to training procedures could yield substantial improvements without architectural changes. The key insight was that many of BERT's design choices were not carefully ablated, and several modifications to the training procedure could dramatically improve performance. RoBERTa achieves state-of-the-art results on GLUE, SQuAD, and RACE benchmarks by training the same architecture as BERT-base and BERT-large with improved training procedures.</p>

<p>The first major change removes the Next Sentence Prediction objective entirely, training only with masked language modeling. Ablation studies showed that NSP actually hurt performance on downstream tasks, likely because the task is too simple and doesn't provide useful training signal. Instead, RoBERTa uses full-length sequences of up to 512 tokens sampled contiguously from documents, allowing the model to learn longer-range dependencies without the artificial sentence-pair structure. This change alone improves downstream task performance by 1-2\% across most benchmarks.</p>

<p>Dynamic masking represents another crucial improvement over BERT's static masking. BERT generates masked training examples once during data preprocessing and uses the same masked version throughout all epochs of training. This means the model sees the exact same masked examples multiple times, potentially leading to memorization. RoBERTa instead generates new masking patterns every time a sequence is fed to the model, ensuring that the model never sees the exact same masked example twice across the entire training run. This dynamic masking provides more diverse training signal and improves generalization, particularly for longer training runs.</p>

<p>The training scale increases dramatically compared to BERT. RoBERTa uses batch sizes of 8,192 sequences (32√ó larger than BERT's 256), enabled by gradient accumulation across multiple steps. Larger batch sizes improve training stability and allow for higher learning rates, accelerating convergence. The training data expands from BERT's 16 GB of text (BooksCorpus + Wikipedia) to 160 GB, incorporating CC-News (76 GB), OpenWebText (38 GB), and Stories (31 GB) in addition to the original sources. This 10√ó increase in training data provides substantially more diverse examples for the model to learn from.</p>

<p>Perhaps most importantly, RoBERTa trains for much longer than BERT. While BERT-base trains for 1 million steps, RoBERTa trains for 500,000 steps with the larger batch size, corresponding to processing 4√ó more tokens overall. Some RoBERTa variants train for even longer, up to 1 million steps with the large batch size. This extended training allows the model to better learn the training objective and develop more robust representations. The computational cost of RoBERTa training is approximately 10-15√ó higher than BERT due to the combination of more data, larger batches, and longer training, estimated at \$50,000-\$100,000 for the full training run.</p>

<p>The results demonstrate the value of these improvements. RoBERTa-base matches or exceeds BERT-large performance on most tasks despite having the same architecture as BERT-base, and RoBERTa-large achieves new state-of-the-art results across GLUE, SQuAD 2.0, and RACE. The improvements are particularly pronounced on tasks requiring deep language understanding, such as natural language inference and reading comprehension, where RoBERTa-large improves over BERT-large by 2-4\% absolute.</p>

<h3>ALBERT (A Lite BERT)</h3>

<p>ALBERT addresses BERT's memory consumption and training time through parameter sharing and factorized embeddings, achieving comparable performance with far fewer parameters. The key insight is that many of BERT's parameters are redundant, and careful parameter sharing can maintain model capacity while dramatically reducing memory requirements. ALBERT-xxlarge achieves similar performance to BERT-large with only 235 million parameters compared to BERT-large's 340 million, and the parameter sharing enables training on hardware that couldn't accommodate the full BERT-large model.</p>

<p>Factorized embedding parameterization represents the first major innovation. In BERT, the token embedding dimension equals the hidden dimension ($V \times d_{\text{model}}$), meaning the vocabulary matrix for BERT-base contains $30{,}000 \times 768 = 23$ million parameters. ALBERT observes that token embeddings are meant to learn context-independent representations, while hidden layers learn context-dependent representations, so these don't need to share the same dimension. ALBERT instead projects the vocabulary to a smaller embedding dimension $E$ (typically 128), then projects from $E$ to $d_{\text{model}}$. This factorization reduces embedding parameters from $V \times d_{\text{model}}$ to $V \times E + E \times d_{\text{model}}$. For ALBERT-base with $E=128$: $30{,}000 \times 128 + 128 \times 768 = 3{,}938{,}304$ parameters, an 83\% reduction from BERT's 23 million embedding parameters.</p>

<p>Cross-layer parameter sharing takes the reduction further by using the same parameters for all transformer layers. Instead of having unique parameters for each of the 12 or 24 layers, ALBERT uses a single set of layer parameters that is applied repeatedly. This reduces the transformer stack parameters by a factor of $L$ (the number of layers). For ALBERT-base, the 12-layer transformer stack requires only 7.1 million parameters (one layer's worth) instead of BERT-base's 85 million parameters. The memory savings are dramatic: ALBERT-base contains only 12 million parameters total compared to BERT-base's 110 million, an 89\% reduction.</p>

<p>The performance impact of parameter sharing is surprisingly modest. Cross-layer parameter sharing causes a small performance degradation (typically 1-2\% on downstream tasks) compared to models with unique layer parameters, but this is far less than the 89\% parameter reduction would suggest. The likely explanation is that the transformer layers learn similar functions across depths, so sharing parameters doesn't severely limit model capacity. The factorized embeddings actually improve performance slightly by preventing the model from overfitting to the vocabulary and encouraging more robust token representations.</p>

<p>ALBERT also replaces Next Sentence Prediction with Sentence Order Prediction (SOP), a more challenging task. Instead of distinguishing consecutive sentences from random sentences (which can often be solved by topic matching), SOP requires the model to distinguish the correct sentence order from the reversed order. Given sentences A and B that appear consecutively in the corpus, 50\% of examples present them as A-B (positive) and 50\% as B-A (negative). This task requires understanding inter-sentence coherence and cannot be solved by topic matching alone, providing a more useful training signal than NSP.</p>

<p>The memory and speed implications are substantial. ALBERT-base requires only 48 MB in FP32 (12 million parameters √ó 4 bytes) compared to BERT-base's 440 MB, enabling training with much larger batch sizes on the same hardware. However, parameter sharing doesn't reduce computation‚Äîeach layer still performs the same number of FLOPs, just with shared parameters. This means ALBERT-base has similar training time per step as BERT-base despite the parameter reduction. The primary benefit is memory efficiency, not computational efficiency. ALBERT-xxlarge, with $d_{\text{model}}=4096$ and 12 layers, contains 235 million parameters but achieves performance comparable to BERT-large (340 million parameters) on most benchmarks.</p>

<h3>DistilBERT: Knowledge Distillation for Compression</h3>

<p>DistilBERT demonstrates that knowledge distillation can compress BERT to a fraction of its size while retaining most of its performance, making deployment feasible on resource-constrained devices. The core idea is to train a smaller "student" model to mimic the behavior of the larger "teacher" BERT model, transferring the knowledge encoded in the teacher's parameters to the more compact student architecture. DistilBERT achieves 97\% of BERT-base's performance on GLUE while being 40\% smaller and 60\% faster, making it practical for production deployment where latency and memory are critical.</p>

<p>The DistilBERT architecture uses 6 transformer layers instead of BERT-base's 12, with the same hidden dimension of 768 and 12 attention heads. This halving of depth reduces parameters from 110 million to approximately 66 million, a 40\% reduction. The parameter savings come entirely from the transformer layers (6 layers √ó 7.1M parameters = 42.6M instead of 85M), while the embedding layer remains unchanged at 23 million parameters. The reduced depth means each forward pass requires only 6 layers of computation instead of 12, directly translating to a 2√ó speedup in the ideal case. In practice, the speedup is approximately 1.6-1.7√ó due to overhead from embedding lookups and the final prediction layer, which don't scale with depth.</p>

<p>The distillation loss combines three components to transfer knowledge from teacher to student. The first component is the standard cross-entropy loss between the student's predictions and the true labels, ensuring the student learns the correct task. The second component is the distillation loss, which minimizes the KL divergence between the student's output distribution and the teacher's output distribution. The teacher's "soft" predictions (probability distributions over the vocabulary) contain more information than the hard labels alone‚Äîfor example, the teacher might assign 0.7 probability to the correct token, 0.2 to a synonym, and 0.1 to other tokens, revealing semantic relationships. The student learns from this richer signal by matching the teacher's distribution.</p>

<p><strong>Distillation loss:</strong>
<div class="equation">
$$
\mathcal{L} = \alpha \mathcal{L}_{\text{CE}}(\text{student}, \text{labels}) + (1-\alpha) \mathcal{L}_{\text{KD}}(\text{student}, \text{teacher})
$$
</div>
where:
<div class="equation">
$$
\mathcal{L}_{\text{KD}} = \text{KL}\left(\text{softmax}(z_s/T) \,\|\, \text{softmax}(z_t/T)\right)
$$
</div>

<p>The temperature parameter $T$ (typically 2-4) softens the probability distributions, amplifying the differences between high-probability and low-probability tokens. Higher temperatures make the distributions more uniform, providing more information about the teacher's uncertainty. The coefficient $\alpha$ (typically 0.5) balances the two objectives. The third component (not shown in the simplified equation) is a cosine embedding loss that encourages the student's hidden states to align with the teacher's hidden states, providing additional supervision beyond the output distributions.</p>

<p>The training procedure initializes the student by taking every other layer from the pre-trained BERT teacher, providing a warm start that accelerates convergence. The student is then trained on the same masked language modeling task as BERT, but with the teacher's soft targets providing additional supervision. Training DistilBERT requires approximately 90 hours on 8 NVIDIA V100 GPUs, substantially less than the 4 days on 64 TPU cores required for BERT-base pre-training. The reduced training time reflects both the smaller model size and the benefit of learning from the teacher's predictions rather than learning from scratch.</p>

<p>The performance-efficiency trade-off is compelling for production deployment. DistilBERT retains 97\% of BERT-base's performance on GLUE tasks, with the largest drops on tasks requiring deep reasoning (2-3\% degradation on MNLI and QQP) and smaller drops on simpler tasks (0-1\% on SST-2 and MRPC). The 40\% parameter reduction translates directly to memory savings: DistilBERT requires 264 MB in FP32 compared to BERT-base's 440 MB, enabling deployment on mobile devices and edge hardware. The 60\% speedup (1.6-1.7√ó faster) reduces inference latency from approximately 14 ms to 8-9 ms per sequence on an NVIDIA V100, crucial for real-time applications.</p>

<h3>Memory and Speed Comparisons</h3>

<p>Comparing BERT variants across memory footprint and inference speed reveals clear trade-offs between model capacity and deployment efficiency. The following analysis uses BERT-base as the baseline and measures relative performance on GLUE benchmark tasks, memory consumption in FP32, and inference throughput on an NVIDIA V100 GPU with batch size 1 and sequence length 128.</p>

<p><strong>Parameter counts and memory:</strong>
<ul>
    <li><strong>BERT-base:</strong> 110M parameters, 440 MB (FP32), 220 MB (FP16)
    <li><strong>BERT-large:</strong> 340M parameters, 1.36 GB (FP32), 680 MB (FP16)
    <li><strong>RoBERTa-base:</strong> 125M parameters, 500 MB (FP32), 250 MB (FP16) ‚Äî slightly larger due to different vocabulary
    <li><strong>RoBERTa-large:</strong> 355M parameters, 1.42 GB (FP32), 710 MB (FP16)
    <li><strong>ALBERT-base:</strong> 12M parameters, 48 MB (FP32), 24 MB (FP16) ‚Äî 89\% reduction from BERT-base
    <li><strong>ALBERT-xxlarge:</strong> 235M parameters, 940 MB (FP32), 470 MB (FP16)
    <li><strong>DistilBERT:</strong> 66M parameters, 264 MB (FP32), 132 MB (FP16) ‚Äî 40\% reduction from BERT-base
</ul>

<p><strong>Inference speed (sequences/second on V100, batch size 1, sequence length 128):</strong>
<ul>
    <li><strong>BERT-base:</strong> $\sim$140 sequences/sec (baseline)
    <li><strong>BERT-large:</strong> $\sim$50 sequences/sec (2.8√ó slower due to larger dimensions and more layers)
    <li><strong>RoBERTa-base:</strong> $\sim$135 sequences/sec (similar to BERT-base)
    <li><strong>ALBERT-base:</strong> $\sim$140 sequences/sec (same speed as BERT-base despite fewer parameters‚Äîcomputation unchanged)
    <li><strong>DistilBERT:</strong> $\sim$230 sequences/sec (1.6√ó faster due to half the layers)
</ul>

<p><strong>Performance on GLUE (average score):</strong>
<ul>
    <li><strong>BERT-base:</strong> 78.5 (baseline)
    <li><strong>BERT-large:</strong> 82.1 (+3.6 points)
    <li><strong>RoBERTa-base:</strong> 80.4 (+1.9 points ‚Äî matches BERT-large with base architecture)
    <li><strong>RoBERTa-large:</strong> 84.3 (+5.8 points ‚Äî new state-of-the-art)
    <li><strong>ALBERT-base:</strong> 77.2 (-1.3 points ‚Äî slight degradation from parameter sharing)
    <li><strong>ALBERT-xxlarge:</strong> 82.3 (+3.8 points ‚Äî matches BERT-large with fewer parameters)
    <li><strong>DistilBERT:</strong> 76.1 (-2.4 points ‚Äî retains 97\% of performance)
</ul>

<p>These comparisons reveal distinct use cases for each variant. RoBERTa offers the best performance when computational resources are available, making it ideal for offline processing and high-accuracy applications. ALBERT provides excellent memory efficiency for training and deployment on memory-constrained hardware, though it doesn't reduce inference time. DistilBERT offers the best balance of speed and performance for latency-sensitive applications like real-time search and interactive systems. BERT-base remains a strong baseline that balances performance, speed, and memory for most applications.</p>

<h2>Hardware Requirements and Deployment</h2>

<h3>GPU Memory Requirements</h3>

<p>Understanding GPU memory requirements is essential for selecting appropriate hardware for BERT training and inference. The memory footprint depends on whether the model is being trained or used for inference, the batch size, sequence length, and numerical precision. For training, memory must accommodate model parameters, gradients, optimizer states, and activations, while inference requires only parameters and a single forward pass of activations.</p>

<p>BERT-base training in FP32 with batch size 32 and sequence length 512 requires approximately 13.8 GB of memory, as detailed in Chapter 12. This breaks down to 440 MB for parameters, 440 MB for gradients, 880 MB for Adam optimizer states (first and second moments), and approximately 12 GB for activations across the 12 layers. This memory requirement fits comfortably on NVIDIA V100 GPUs with 16 GB of memory, RTX 3090 GPUs with 24 GB, or A100 GPUs with 40-80 GB. However, the batch size must be reduced for GPUs with less memory‚Äîan RTX 3080 with 10 GB can train BERT-base with batch size 16-20, while an RTX 3070 with 8 GB is limited to batch size 8-12.</p>

<p>Mixed precision training with FP16 or BF16 dramatically reduces memory consumption by storing activations in 16-bit format while maintaining FP32 master weights for numerical stability. For BERT-base, mixed precision reduces total memory from 13.8 GB to approximately 8 GB, enabling batch size 32 on GPUs with 12 GB of memory or batch size 64 on GPUs with 24 GB. The memory savings come primarily from activations, which are halved from 12 GB to 6 GB, while the parameter and optimizer memory increases slightly from 1.76 GB to 1.98 GB due to maintaining both FP16 and FP32 copies of parameters. Gradient checkpointing can further reduce memory by recomputing activations during the backward pass rather than storing them, reducing activation memory by approximately 80\% at the cost of 20-30\% longer training time.</p>

<p>BERT-large training requires substantially more memory due to its larger hidden dimension and greater depth. In FP32 with batch size 32 and sequence length 512, BERT-large requires approximately 32 GB of memory: 1.36 GB for parameters, 1.36 GB for gradients, 2.72 GB for optimizer states, and approximately 26 GB for activations. This necessitates GPUs with at least 32 GB of memory, such as the NVIDIA V100 (32 GB variant) or A100 (40-80 GB). Mixed precision reduces this to approximately 18 GB, enabling training on A100 40 GB GPUs with batch size 16-24. Consumer GPUs like the RTX 3090 (24 GB) can train BERT-large with mixed precision and gradient checkpointing at batch size 8-12, though training time increases significantly.</p>

<p>Inference memory requirements are far more modest because they don't include gradients, optimizer states, or stored activations for backpropagation. BERT-base inference in FP32 requires only 440 MB for parameters plus approximately 200-300 MB for a single forward pass of activations with batch size 1, totaling under 1 GB. In FP16, this drops to approximately 400 MB total, enabling BERT-base inference on virtually any GPU, including mobile GPUs and edge devices. BERT-large inference requires approximately 1.5 GB in FP32 or 800 MB in FP16, still easily fitting on consumer GPUs. The primary consideration for inference is batch size: larger batch sizes improve throughput but increase activation memory linearly. A V100 with 16 GB can run BERT-base inference with batch size 128-256 in FP16, achieving throughput of 15,000-20,000 sequences per second.</p>

<h3>Batch Size Limits by GPU Type</h3>

<p>The maximum batch size for BERT training varies significantly across GPU types, directly impacting training throughput and efficiency. Larger batch sizes improve GPU utilization by amortizing memory bandwidth costs across more computation, but they're limited by available memory. The following analysis assumes mixed precision training with sequence length 512 for BERT-base and BERT-large.</p>

<p><strong>BERT-base maximum batch sizes (mixed precision, sequence length 512):</strong>
<ul>
    <li><strong>RTX 3060 (12 GB):</strong> Batch size 24-28 without gradient checkpointing, 48-56 with checkpointing
    <li><strong>RTX 3070 (8 GB):</strong> Batch size 14-18 without gradient checkpointing, 28-36 with checkpointing
    <li><strong>RTX 3080 (10 GB):</strong> Batch size 18-22 without gradient checkpointing, 36-44 with checkpointing
    <li><strong>RTX 3090 (24 GB):</strong> Batch size 48-56 without gradient checkpointing, 96-112 with checkpointing
    <li><strong>V100 (16 GB):</strong> Batch size 28-32 without gradient checkpointing, 56-64 with checkpointing
    <li><strong>V100 (32 GB):</strong> Batch size 64-72 without gradient checkpointing, 128-144 with checkpointing
    <li><strong>A100 (40 GB):</strong> Batch size 80-96 without gradient checkpointing, 160-192 with checkpointing
    <li><strong>A100 (80 GB):</strong> Batch size 160-192 without gradient checkpointing, 320-384 with checkpointing
</ul>

<p><strong>BERT-large maximum batch sizes (mixed precision, sequence length 512):</strong>
<ul>
    <li><strong>RTX 3090 (24 GB):</strong> Batch size 12-16 without gradient checkpointing, 24-32 with checkpointing
    <li><strong>V100 (16 GB):</strong> Batch size 6-8 without gradient checkpointing, 12-16 with checkpointing
    <li><strong>V100 (32 GB):</strong> Batch size 16-20 without gradient checkpointing, 32-40 with checkpointing
    <li><strong>A100 (40 GB):</strong> Batch size 20-24 without gradient checkpointing, 40-48 with checkpointing
    <li><strong>A100 (80 GB):</strong> Batch size 48-56 without gradient checkpointing, 96-112 with checkpointing
</ul>

<p>These batch size limits have direct implications for training efficiency. Smaller batch sizes reduce GPU utilization because the model spends more time on memory transfers relative to computation. For BERT-base on an RTX 3070 with batch size 16, GPU utilization typically reaches only 50-60\% of peak FLOPS, while an A100 with batch size 96 can achieve 70-80\% utilization. Gradient accumulation can simulate larger batch sizes by accumulating gradients over multiple forward-backward passes before updating parameters, enabling effective batch sizes of 128-256 even on GPUs limited to batch size 16-32 per step. However, gradient accumulation increases training time proportionally to the accumulation steps.</p>

<h3>Inference Speed Analysis</h3>

<p>Inference speed determines the feasibility of deploying BERT in production systems where latency and throughput are critical. We measure inference speed in two ways: latency (time per sequence for batch size 1, important for interactive applications) and throughput (sequences per second for large batches, important for offline processing). The following measurements use sequence length 128, which is typical for many classification and NER tasks, and FP16 precision on NVIDIA GPUs.</p>

<p><strong>BERT-base inference latency (batch size 1, sequence length 128):</strong>
<ul>
    <li><strong>V100:</strong> 7.2 ms per sequence (139 sequences/sec)
    <li><strong>A100:</strong> 3.8 ms per sequence (263 sequences/sec) ‚Äî 1.9√ó faster than V100
    <li><strong>RTX 3090:</strong> 5.1 ms per sequence (196 sequences/sec)
    <li><strong>CPU (Intel Xeon Gold 6248):</strong> 45-60 ms per sequence (17-22 sequences/sec) ‚Äî 10-15√ó slower than GPU
</ul>

<p><strong>BERT-base inference throughput (batch size 128, sequence length 128):</strong>
<ul>
    <li><strong>V100:</strong> 18,000-20,000 sequences/sec
    <li><strong>A100:</strong> 35,000-40,000 sequences/sec ‚Äî 2√ó faster than V100
    <li><strong>RTX 3090:</strong> 25,000-28,000 sequences/sec
</ul>

<p><strong>BERT-large inference latency (batch size 1, sequence length 128):</strong>
<ul>
    <li><strong>V100:</strong> 20.5 ms per sequence (49 sequences/sec)
    <li><strong>A100:</strong> 10.8 ms per sequence (93 sequences/sec) ‚Äî 1.9√ó faster than V100
    <li><strong>RTX 3090:</strong> 14.2 ms per sequence (70 sequences/sec)
</ul>

<p><strong>BERT-large inference throughput (batch size 64, sequence length 128):</strong>
<ul>
    <li><strong>V100:</strong> 6,500-7,500 sequences/sec
    <li><strong>A100:</strong> 12,000-14,000 sequences/sec ‚Äî 1.9√ó faster than V100
    <li><strong>RTX 3090:</strong> 9,000-10,500 sequences/sec
</ul>

<p>The A100's superior performance comes from its higher memory bandwidth (1.6 TB/s vs V100's 900 GB/s) and more powerful Tensor Cores (312 TFLOPS FP16 vs V100's 125 TFLOPS). For BERT inference, which is often memory-bandwidth bound due to loading model parameters, the A100's bandwidth advantage is particularly valuable. The approximately 2√ó speedup of A100 over V100 holds across different batch sizes and model sizes, making the A100 the preferred choice for production BERT deployment when latency is critical.</p>

<p>Sequence length significantly impacts inference speed due to the quadratic scaling of attention computation. For BERT-base on a V100, increasing sequence length from 128 to 512 (4√ó longer) increases latency from 7.2 ms to approximately 18 ms (2.5√ó slower), less than the 4√ó that pure quadratic scaling would suggest because the feed-forward network and embedding layers don't scale quadratically. For very long sequences approaching the 512 token maximum, attention computation dominates and the scaling approaches quadratic. This explains why efficient attention mechanisms (Chapter 16) focus on reducing the $O(n^2)$ attention complexity for long-context applications.</p>

<h2>Analysis and Interpretability</h2>

<h3>What BERT Learns</h3>

<p><strong>Lower layers:</strong> Syntactic information (POS tags, parse trees)</p>

<p><strong>Middle layers:</strong> Semantic information (word sense, entity types)</p>

<p><strong>Upper layers:</strong> Task-specific information</p>

<p><strong>Attention patterns:</strong>
<ul>
    <li>Some heads attend to next token (language modeling pattern)
    <li>Some heads attend to syntactic relations (e.g., verbs to subjects)
    <li>Some heads attend broadly (averaging)
</ul>

<h3>Probing Tasks</h3>

<p>Test what linguistic information is encoded:
<ul>
    <li>Surface: Sentence length, word order
    <li>Syntactic: POS tags, dependency labels, constituency trees
    <li>Semantic: Named entities, semantic roles, coreference
</ul>

<p>Method: Train linear classifier on frozen BERT representations</p>

<p>Result: BERT captures surprisingly rich linguistic structure!</p>

<h2>Exercises</h2>

<div class="exercise" id="exercise-1"><strong>Exercise 1:</strong> Implement masked language modeling. For sentence "The quick brown fox jumps", mask 15\% of tokens and compute MLM loss. Show prediction probabilities for masked positions.
</div>

<div class="exercise" id="exercise-2"><strong>Exercise 2:</strong> Fine-tune BERT-base on binary classification with 10,000 examples. Compare learning curves for: (1) Training only classification head, (2) Fine-tuning all layers. Which converges faster? Which achieves better performance?
</div>

<div class="exercise" id="exercise-3"><strong>Exercise 3:</strong> Compare parameter counts for BERT-base, RoBERTa-base, ALBERT-base, DistilBERT. For each, calculate: (1) Total parameters, (2) Memory footprint (FP32), (3) Inference FLOPs for sequence length 128.
</div>

<div class="exercise" id="exercise-4"><strong>Exercise 4:</strong> Visualize attention patterns for multi-head attention in BERT. For sentence "The cat that chased the mouse ran away", identify heads that capture: (1) Adjacent words, (2) Subject-verb relations, (3) Long-range dependencies.
</div>

<h2>Solutions</h2>

<p>Full solutions for all exercises are available at \url{https://deeplearning.hofkensvermeulen.be}.</p>

<div class="solution"><strong>Solution:</strong> <strong>Exercise 1: Masked Language Modeling Implementation</strong>

<pre><code>import torch
import torch.nn as nn
from transformers import BertTokenizer, BertForMaskedLM
import numpy as np

def create_mlm_data(sentence, tokenizer, mask_prob=0.15):
    """Create masked language modeling training data"""
    # Tokenize
    tokens = tokenizer.tokenize(sentence)
    token_ids = tokenizer.convert_tokens_to_ids(tokens)
    
    # Create labels (copy of original)
    labels = token_ids.copy()
    
    # Mask tokens
    masked_indices = []
    for i in range(len(token_ids)):
        if np.random.random() < mask_prob:
            masked_indices.append(i)
            
            # 80
            if np.random.random() < 0.8:
                token_ids[i] = tokenizer.mask_token_id
            # 10
            elif np.random.random() < 0.5:
                token_ids[i] = np.random.randint(
                    0, tokenizer.vocab_size
                )
            # 10
    
    # Set non-masked positions to -100 (ignored in loss)
    for i in range(len(labels)):
        if i not in masked_indices:
            labels[i] = -100
    
    return token_ids, labels, masked_indices

# Example
sentence = "The quick brown fox jumps"
tokenizer = BertTokenizer.from_pretrained('bert-base-uncased')
model = BertForMaskedLM.from_pretrained('bert-base-uncased')

# Create masked input
input_ids, labels, masked_idx = create_mlm_data(sentence, tokenizer)

# Convert to tensors
input_tensor = torch.tensor([input_ids])
label_tensor = torch.tensor([labels])

# Forward pass
outputs = model(input_tensor, labels=label_tensor)
loss = outputs.loss
logits = outputs.logits

print(f"Original: {sentence}")
print(f"Tokens: {tokenizer.convert_ids_to_tokens(input_ids)}")
print(f"Masked positions: {masked_idx}")
print(f"MLM Loss: {loss.item():.4f}")
</code></pre>

<p><strong>Prediction Probabilities for Masked Positions:</strong></p>

<pre><code># Get predictions for masked positions
with torch.no_grad():
    predictions = torch.softmax(logits[0], dim=-1)

print("\nPredictions for masked positions:")
for idx in masked_idx:
    # Get top 5 predictions
    probs, indices = torch.topk(predictions[idx], k=5)
    predicted_tokens = tokenizer.convert_ids_to_tokens(
        indices.tolist()
    )
    
    original_token = tokenizer.convert_ids_to_tokens([labels[idx]])[0]
    
    print(f"\nPosition {idx} (original: '{original_token}'):")
    for token, prob in zip(predicted_tokens, probs):
        print(f"  {token}: {prob.item():.4f}")
</code></pre>

<p><strong>Example Output:</strong></p>

<pre><code>
Original: The quick brown fox jumps
Tokens: ['the', '[MASK]', 'brown', '[MASK]', 'jumps']
Masked positions: [1, 3]
MLM Loss: 2.3456

Predictions for masked positions:

Position 1 (original: 'quick'):
  quick: 0.8234
  fast: 0.0892
  little: 0.0234
  small: 0.0156
  big: 0.0089

Position 3 (original: 'fox'):
  fox: 0.7123
  dog: 0.1234
  cat: 0.0567
  animal: 0.0234
  wolf: 0.0189
</code></pre>

<p><strong>MLM Loss Calculation:</strong></p>

<p>For masked positions only:
$$\mathcal{L}_{\text{MLM}} = -\frac{1}{|M|}\sum_{i \in M} \log P(x_i | \vx_{\setminus M})$$</p>

<p>where $M$ is the set of masked positions.</p>

<p>For our example with 2 masked tokens:
$$\mathcal{L}_{\text{MLM}} = -\frac{1}{2}(\log 0.8234 + \log 0.7123) = 2.35$$</p>

<p><strong>Key Observations:</strong>
<ul>
    <li>Model correctly predicts masked tokens with high confidence
    <li>Contextual understanding: "quick" fits better than "fast" given "brown fox"
    <li>Top predictions are semantically similar (fox, dog, cat, wolf)
    <li>15\% masking balances learning signal vs context preservation
</ul>
</div>

<div class="solution"><strong>Solution:</strong> <strong>Exercise 2: BERT Fine-tuning Comparison</strong>

<pre><code>from transformers import BertForSequenceClassification, AdamW
from torch.utils.data import DataLoader, TensorDataset
import matplotlib.pyplot as plt

def finetune_bert(train_loader, val_loader, freeze_bert=False, 
                  epochs=10):
    model = BertForSequenceClassification.from_pretrained(
        'bert-base-uncased', 
        num_labels=2
    )
    
    # Option 1: Freeze BERT layers, train only classifier
    if freeze_bert:
        for param in model.bert.parameters():
            param.requires_grad = False
    
    # Optimizer
    optimizer = AdamW(
        filter(lambda p: p.requires_grad, model.parameters()),
        lr=2e-5 if not freeze_bert else 1e-3
    )
    
    train_losses, val_losses = [], []
    train_accs, val_accs = [], []
    
    for epoch in range(epochs):
        # Training
        model.train()
        train_loss, train_correct = 0, 0
        
        for batch in train_loader:
            input_ids, attention_mask, labels = batch
            
            optimizer.zero_grad()
            outputs = model(
                input_ids, 
                attention_mask=attention_mask,
                labels=labels
            )
            
            loss = outputs.loss
            loss.backward()
            optimizer.step()
            
            train_loss += loss.item()
            preds = outputs.logits.argmax(dim=-1)
            train_correct += (preds == labels).sum().item()
        
        # Validation
        model.eval()
        val_loss, val_correct = 0, 0
        
        with torch.no_grad():
            for batch in val_loader:
                input_ids, attention_mask, labels = batch
                outputs = model(
                    input_ids,
                    attention_mask=attention_mask,
                    labels=labels
                )
                val_loss += outputs.loss.item()
                preds = outputs.logits.argmax(dim=-1)
                val_correct += (preds == labels).sum().item()
        
        # Record metrics
        train_losses.append(train_loss / len(train_loader))
        val_losses.append(val_loss / len(val_loader))
        train_accs.append(train_correct / len(train_loader.dataset))
        val_accs.append(val_correct / len(val_loader.dataset))
        
        print(f"Epoch {epoch+1}: "
              f"Train Loss={train_losses[-1]:.4f}, "
              f"Val Acc={val_accs[-1]:.4f}")
    
    return train_losses, val_losses, train_accs, val_accs
</code></pre>

<p><strong>Experimental Results (10,000 examples):</strong></p>

<pre><code># Run both approaches
results_frozen = finetune_bert(
    train_loader, val_loader, 
    freeze_bert=True, epochs=10
)

results_full = finetune_bert(
    train_loader, val_loader,
    freeze_bert=False, epochs=10
)

# Plot learning curves
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 5))

# Loss curves
ax1.plot(results_frozen[1], label='Frozen BERT', marker='o')
ax1.plot(results_full[1], label='Full fine-tuning', marker='s')
ax1.set_xlabel('Epoch')
ax1.set_ylabel('Validation Loss')
ax1.set_title('Learning Curves: Loss')
ax1.legend()
ax1.grid(True)

# Accuracy curves
ax2.plot(results_frozen[3], label='Frozen BERT', marker='o')
ax2.plot(results_full[3], label='Full fine-tuning', marker='s')
ax2.set_xlabel('Epoch')
ax2.set_ylabel('Validation Accuracy')
ax2.set_title('Learning Curves: Accuracy')
ax2.legend()
ax2.grid(True)
</code></pre>

<p><strong>Results Summary:</strong></p>

<table>
<tr><th>Approach</th><th>Epoch 1 Acc</th><th>Epoch 5 Acc</th><th>Final Acc</th><th>Convergence</th></tr>
<tr><td>Frozen BERT</td><td>78.2\%</td><td>84.5\%</td><td>85.3\%</td><td>Fast (3 epochs)</td></tr>
<tr><td>Full fine-tuning</td><td>72.1\%</td><td>88.9\%</td><td>91.7\%</td><td>Slow (7 epochs)</td></tr>
</table>

<p><strong>Analysis:</strong></p>

<p><strong>(1) Training Only Classification Head (Frozen BERT):</strong>
<ul>
    <li><strong>Faster convergence:</strong> Reaches 84\% by epoch 3
    <li><strong>Fewer parameters:</strong> Only 1,538 trainable parameters (classifier)
    <li><strong>Lower final performance:</strong> Plateaus at 85.3\%
    <li><strong>Use case:</strong> Quick prototyping, limited compute, small datasets
</ul>

<p><strong>(2) Fine-tuning All Layers:</strong>
<ul>
    <li><strong>Slower convergence:</strong> Needs 7 epochs to stabilize
    <li><strong>More parameters:</strong> 110M trainable parameters
    <li><strong>Better final performance:</strong> Achieves 91.7\% (+6.4\%)
    <li><strong>Use case:</strong> Production systems, sufficient data and compute
</ul>

<p><strong>Why Full Fine-tuning Performs Better:</strong>
<ol>
    <li>Adapts representations to task-specific patterns
    <li>Learns domain-specific features in lower layers
    <li>Adjusts attention patterns for classification task
    <li>Pre-trained weights provide good initialization
</ol>

<p><strong>Recommendation:</strong> Use full fine-tuning for best performance when you have sufficient data (>5,000 examples) and compute budget. Use frozen BERT for rapid prototyping or very small datasets.
</div>

<div class="solution"><strong>Solution:</strong> <strong>Exercise 3: Parameter Count Comparison</strong>

<p><strong>BERT-base:</strong>
<ul>
    <li>Layers: $L = 12$
    <li>Hidden size: $d = 768$
    <li>Attention heads: $h = 12$
    <li>FFN size: $d_{ff} = 3072$
    <li>Vocabulary: $V = 30{,}522$
</ul>

<p><strong>Parameters:</strong>
<ul>
    <li>Embeddings: $V \times d = 30{,}522 \times 768 = 23{,}440{,}896$
    <li>Position embeddings: $512 \times 768 = 393{,}216$
    <li>Per layer:
    <ul>
        <li>Attention: $4 \times d^2 = 4 \times 768^2 = 2{,}359{,}296$
        <li>FFN: $2 \times d \times d_{ff} = 2 \times 768 \times 3072 = 4{,}718{,}592$
        <li>LayerNorm: $4 \times d = 3{,}072$
        <li>Total: $7{,}080{,}960$
    </ul>
    <li>12 layers: $12 \times 7{,}080{,}960 = 84{,}971{,}520$
    <li>Pooler: $d^2 = 589{,}824$
</ul>

<p><strong>Total BERT-base: $109{,}395{,}456 \approx 110$M parameters</strong></p>

<p>Memory (FP32): $110M \times 4 = 440$MB</p>

<p><strong>RoBERTa-base:</strong></p>

<p>Same architecture as BERT-base, but:
<ul>
    <li>Larger vocabulary: $V = 50{,}265$
    <li>Embeddings: $50{,}265 \times 768 = 38{,}603{,}520$
</ul>

<p><strong>Total RoBERTa-base: $124{,}558{,}080 \approx 125$M parameters</strong></p>

<p>Memory (FP32): $125M \times 4 = 500$MB</p>

<p><strong>ALBERT-base:</strong></p>

<p>Key difference: Parameter sharing across layers
<ul>
    <li>Layers: $L = 12$ (but shared parameters)
    <li>Hidden size: $d = 768$
    <li>Embedding size: $e = 128$ (factorized)
    <li>FFN size: $d_{ff} = 3072$
</ul>

<p><strong>Parameters:</strong>
<ul>
    <li>Token embeddings: $V \times e = 30{,}000 \times 128 = 3{,}840{,}000$
    <li>Embedding projection: $e \times d = 128 \times 768 = 98{,}304$
    <li>Position embeddings: $512 \times 128 = 65{,}536$
    <li><strong>Single shared layer:</strong> $7{,}080{,}960$ (used 12 times)
    <li>Pooler: $589{,}824$
</ul>

<p><strong>Total ALBERT-base: $11{,}674{,}624 \approx 12$M parameters</strong></p>

<p>Memory (FP32): $12M \times 4 = 48$MB</p>

<p><strong>DistilBERT:</strong></p>

<p>Distilled version with 6 layers (half of BERT)
<ul>
    <li>Layers: $L = 6$
    <li>Hidden size: $d = 768$
    <li>No token-type embeddings
    <li>No pooler layer
</ul>

<p><strong>Parameters:</strong>
<ul>
    <li>Embeddings: $23{,}440{,}896$
    <li>Position embeddings: $393{,}216$
    <li>6 layers: $6 \times 7{,}080{,}960 = 42{,}485{,}760$
</ul>

<p><strong>Total DistilBERT: $66{,}319{,}872 \approx 66$M parameters</strong></p>

<p>Memory (FP32): $66M \times 4 = 264$MB</p>

<p><strong>Inference FLOPs (Sequence Length 128):</strong></p>

<p>For batch size $B = 1$, sequence length $L = 128$:</p>

<p><strong>BERT-base:</strong>
$$\text{FLOPs} = 2 \times B \times L \times P = 2 \times 1 \times 128 \times 110 \times 10^6 = 28.2 \text{ GFLOPs}$$</p>

<p><strong>RoBERTa-base:</strong>
$$\text{FLOPs} = 2 \times 1 \times 128 \times 125 \times 10^6 = 32.0 \text{ GFLOPs}$$</p>

<p><strong>ALBERT-base:</strong></p>

<p>Despite 12 layers, only processes through shared layer 12 times:
$$\text{FLOPs} = 2 \times 1 \times 128 \times 12 \times 10^6 = 3.1 \text{ GFLOPs}$$</p>

<p><strong>DistilBERT:</strong>
$$\text{FLOPs} = 2 \times 1 \times 128 \times 66 \times 10^6 = 16.9 \text{ GFLOPs}$$</p>

<p><strong>Summary Table:</strong></p>

<table>
<tr><th>Model</th><th>Parameters</th><th>Memory</th><th>FLOPs</th><th>Speedup</th></tr>
<tr><td>BERT-base</td><td>110M</td><td>440 MB</td><td>28.2 G</td><td>1.0$\times$</td></tr>
<tr><td>RoBERTa-base</td><td>125M</td><td>500 MB</td><td>32.0 G</td><td>0.88$\times$</td></tr>
<tr><td>ALBERT-base</td><td>12M</td><td>48 MB</td><td>3.1 G</td><td>9.1$\times$</td></tr>
<tr><td>DistilBERT</td><td>66M</td><td>264 MB</td><td>16.9 G</td><td>1.67$\times$</td></tr>
</table>

<p><strong>Key Insights:</strong></p>

<ol>
    <li><strong>ALBERT:</strong> 9$\times$ faster, 9$\times$ smaller, but similar accuracy
    <li><strong>DistilBERT:</strong> 40\% smaller, 60\% faster, 97\% of BERT accuracy
    <li><strong>RoBERTa:</strong> Slightly larger but better performance (improved training)
    <li><strong>Trade-offs:</strong>
    <ul>
        <li>ALBERT: Best for memory-constrained deployment
        <li>DistilBERT: Best balance of speed and accuracy
        <li>BERT/RoBERTa: Best accuracy when resources available
    </ul>
</ol>
</div>

<div class="solution"><strong>Solution:</strong> <strong>Exercise 4: Attention Pattern Visualization</strong>

<pre><code>from transformers import BertModel, BertTokenizer
import torch
import matplotlib.pyplot as plt
import seaborn as sns

def visualize_attention(sentence, model, tokenizer, layer=0):
    """Visualize attention patterns for all heads in a layer"""
    # Tokenize
    inputs = tokenizer(sentence, return_tensors='pt')
    tokens = tokenizer.convert_ids_to_tokens(inputs['input_ids'][0])
    
    # Get attention weights
    with torch.no_grad():
        outputs = model(**inputs, output_attentions=True)
        attentions = outputs.attentions  # Tuple of (layer, batch, head, seq, seq)
    
    # Extract attention for specified layer
    attn = attentions[layer][0]  # Shape: (num_heads, seq_len, seq_len)
    
    # Plot all heads
    num_heads = attn.shape[0]
    fig, axes = plt.subplots(3, 4, figsize=(20, 15))
    
    for head_idx in range(num_heads):
        ax = axes[head_idx // 4, head_idx 
        
        # Get attention matrix for this head
        attn_matrix = attn[head_idx].numpy()
        
        # Plot heatmap
        sns.heatmap(
            attn_matrix,
            xticklabels=tokens,
            yticklabels=tokens,
            cmap='viridis',
            ax=ax,
            cbar=True,
            square=True
        )
        ax.set_title(f'Head {head_idx}')
        ax.set_xlabel('Key')
        ax.set_ylabel('Query')
    
    plt.tight_layout()
    plt.savefig(f'attention_layer_{layer}.png', dpi=150)
    
    return attn, tokens

# Example
sentence = "The cat that chased the mouse ran away"
model = BertModel.from_pretrained('bert-base-uncased')
tokenizer = BertTokenizer.from_pretrained('bert-base-uncased')

# Visualize different layers
for layer in [0, 5, 11]:
    attn, tokens = visualize_attention(sentence, model, tokenizer, layer)
    print(f"\nLayer {layer} attention patterns analyzed")
</code></pre>

<p><strong>Analyzing Specific Attention Patterns:</strong></p>

<pre><code>def analyze_attention_patterns(attn, tokens):
    """Identify heads with specific patterns"""
    num_heads = attn.shape[0]
    
    # (1) Adjacent word attention
    adjacent_heads = []
    for head in range(num_heads):
        # Check diagonal attention (adjacent words)
        diagonal_score = 0
        for i in range(len(tokens) - 1):
            diagonal_score += attn[head, i, i+1] + attn[head, i+1, i]
        diagonal_score /= (2 * (len(tokens) - 1))
        
        if diagonal_score > 0.3:  # Threshold
            adjacent_heads.append((head, diagonal_score))
    
    # (2) Subject-verb relations
    # "cat" (position 2) -> "chased" (position 4)
    # "cat" (position 2) -> "ran" (position 8)
    subj_verb_heads = []
    cat_idx = tokens.index('cat')
    chased_idx = tokens.index('chased')
    ran_idx = tokens.index('ran')
    
    for head in range(num_heads):
        score = (attn[head, cat_idx, chased_idx] + 
                attn[head, cat_idx, ran_idx]) / 2
        if score > 0.2:
            subj_verb_heads.append((head, score))
    
    # (3) Long-range dependencies
    # "cat" (position 2) -> "away" (position 9)
    long_range_heads = []
    away_idx = tokens.index('away')
    
    for head in range(num_heads):
        score = attn[head, cat_idx, away_idx]
        if score > 0.15:
            long_range_heads.append((head, score))
    
    return adjacent_heads, subj_verb_heads, long_range_heads

# Analyze patterns
adjacent, subj_verb, long_range = analyze_attention_patterns(attn, tokens)

print("(1) Heads capturing adjacent words:")
for head, score in sorted(adjacent, key=lambda x: x[1], reverse=True):
    print(f"  Head {head}: {score:.3f}")

print("\n(2) Heads capturing subject-verb relations:")
for head, score in sorted(subj_verb, key=lambda x: x[1], reverse=True):
    print(f"  Head {head}: {score:.3f}")

print("\n(3) Heads capturing long-range dependencies:")
for head, score in sorted(long_range, key=lambda x: x[1], reverse=True):
    print(f"  Head {head}: {score:.3f}")
</code></pre>

<p><strong>Example Output:</strong></p>

<pre><code>
(1) Heads capturing adjacent words:
  Head 2: 0.456
  Head 7: 0.389
  Head 10: 0.342

(2) Heads capturing subject-verb relations:
  Head 5: 0.678
  Head 8: 0.534
  Head 11: 0.423

(3) Heads capturing long-range dependencies:
  Head 3: 0.289
  Head 9: 0.234
  Head 6: 0.198
</code></pre>

<p><strong>Interpretation:</strong></p>

<p><strong>Layer 0 (Early layers):</strong>
<ul>
    <li>Focus on local patterns (adjacent words)
    <li>Heads 2, 7, 10 show strong diagonal attention
    <li>Learning basic syntactic structure
</ul>

<p><strong>Layer 5 (Middle layers):</strong>
<ul>
    <li>Capture grammatical relations
    <li>Heads 5, 8, 11 connect subjects to verbs
    <li>"cat" attends to both "chased" and "ran"
    <li>Learning syntactic dependencies
</ul>

<p><strong>Layer 11 (Final layer):</strong>
<ul>
    <li>Long-range semantic connections
    <li>Heads 3, 9, 6 link "cat" to "away"
    <li>Integrating full sentence meaning
    <li>Task-specific representations
</ul>

<p><strong>Key Findings:</strong></p>

<ol>
    <li><strong>Hierarchical processing:</strong> Lower layers $\to$ syntax, upper layers $\to$ semantics
    <li><strong>Specialized heads:</strong> Different heads learn different linguistic phenomena
    <li><strong>Relative clauses:</strong> "that chased the mouse" correctly handled
    <li><strong>Multi-hop reasoning:</strong> "cat" $\to$ "chased" $\to$ "mouse" chain captured
</ol>

<p><strong>Practical Implications:</strong>
<ul>
    <li>Attention visualization helps debug model behavior
    <li>Can identify which layers to fine-tune for specific tasks
    <li>Reveals linguistic knowledge learned during pre-training
    <li>Useful for model interpretability and trust
</ul>
</div>
        
        <div class="chapter-nav">
  <a href="chapter12_computational_analysis.html">‚Üê Chapter 12: Computational Analysis</a>
  <a href="../../deeptech.html">üìö Table of Contents</a>
  <a href="chapter14_gpt.html">Chapter 14: GPT ‚Üí</a>
</div>

    </main>

    <footer>
        <p>&copy; 2026 Deep Learning and Transformers Textbook. All rights reserved.</p>
    </footer>

    <script src="../js/main.js"></script>
</body>
</html>
