<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bridge: From Foundations to Architecture - Deep Learning and LLMs for Technical Leaders</title>
    <link rel="stylesheet" href="../../styles.css">
    <style>
        /* Additional styles for formula boxes */
        .formula-box {
            background: #f8f9fa;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1.5rem auto;
            text-align: center;
            max-width: 85%;
            font-size: 1.1em;
        }
        .formula-box p {
            margin: 0.5rem 0;
        }
    </style>
    <script>
    window.MathJax = {
        tex: {
            inlineMath: [['$', '$'], ['\\(', '\\)']],
            displayMath: [['$$', '$$'], ['\\[', '\\]']],
            processEscapes: true,
            processEnvironments: true,
            tags: 'ams',
            packages: {'[+]': ['ams', 'newcommand', 'configmacros']},
            macros: {
                R: '{\\mathbb{R}}', N: '{\\mathbb{N}}', Z: '{\\mathbb{Z}}', C: '{\\mathbb{C}}',
                vx: '{\\mathbf{x}}', vy: '{\\mathbf{y}}', vz: '{\\mathbf{z}}',
                vh: '{\\mathbf{h}}', vw: '{\\mathbf{w}}', vb: '{\\mathbf{b}}',
                vq: '{\\mathbf{q}}', vk: '{\\mathbf{k}}', vv: '{\\mathbf{v}}',
                mA: '{\\mathbf{A}}', mB: '{\\mathbf{B}}', mC: '{\\mathbf{C}}',
                mW: '{\\mathbf{W}}', mX: '{\\mathbf{X}}', mY: '{\\mathbf{Y}}',
                mQ: '{\\mathbf{Q}}', mK: '{\\mathbf{K}}', mV: '{\\mathbf{V}}',
                mH: '{\\mathbf{H}}', mI: '{\\mathbf{I}}', mU: '{\\mathbf{U}}', mM: '{\\mathbf{M}}',
                transpose: '{^\\top}', norm: ['\\left\\|#1\\right\\|', 1], abs: ['\\left|#1\\right|', 1]
            }
        },
        startup: { pageReady: () => { console.log('MathJax loaded'); return MathJax.startup.defaultPageReady(); } }
    };
    </script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>
    <main><h1>Part I Equipped You To Ask "How?"</h1>

<h2>What You Now Understand</h2>

<p>Part I established the technical foundation for evaluating AI systems. You now understand why costs scale cubically with dimension‚Äîdoubling model dimensions increases computation eightfold, not twofold. You recognize where memory bottlenecks appear‚Äîactivations consume 60\% of training memory, making batch size the primary control lever. You understand how attention mechanisms work‚Äîthe Query-Key-Value architecture that enables context processing with quadratic scaling costs.</p>

<p>These aren't abstract concepts. They're the foundation for every technical decision you'll face. When a vendor proposes "upgrading to a larger model," you can now calculate the actual cost impact. When your team suggests "extending context windows," you know that doubling context length quadruples attention costs. When evaluating training proposals, you can verify whether the memory requirements match the claimed model size using the 14√ó rule.</p>

<h2>What You Can Now Evaluate</h2>

<p>The mental models from Part I provide rapid evaluation frameworks. Cost Driver Dominance helps you identify where 80\% of costs originate and focus optimization efforts accordingly. The Batch Size Sweet Spot guides you to the 32-128 range where GPU utilization and convergence quality balance optimally. Context Length Economic Threshold reveals when retrieval augmentation becomes 10√ó cheaper than long-context models.</p>

<p>You can now spot unreasonable proposals. "We need a 1024-dimensional model" triggers the cubic scaling calculation‚Äîthat's approximately 8√ó more expensive than 768 dimensions. "Training needs 80GB GPU" prompts verification against the 14√ó memory rule. "Context length of 8K tokens" immediately registers as 4√ó more expensive than 4K tokens due to quadratic attention scaling.</p>

<p>The cautionary tales illustrated real failure modes. The fintech startup that underestimated training memory by ignoring the 14√ó rule, wasting weeks and thousands of dollars. The e-commerce company whose training took 10√ó longer than estimated because they calculated from theoretical FLOPS without profiling actual bottlenecks. These failures are now avoidable‚Äîyou have the frameworks to catch them during proposal review.</p>

<h2>The Transition: From "How?" to "Which?"</h2>

<p>Part I taught you costs‚Äîhow systems work and what drives resource consumption. Part II teaches you choices‚Äîwhich approaches work for which problems and when architectural decisions determine success or failure.</p>

<p>Understanding costs is necessary but insufficient. Knowing that fine-tuning costs \$5K doesn't tell you whether fine-tuning is the right choice. Knowing that distributed training enables larger models doesn't reveal when distributed training is necessary versus wasteful. Knowing that compression reduces inference costs doesn't indicate which compression technique applies to your constraints.</p>

<p>Part II addresses these architectural decisions. You'll learn when to train from scratch versus fine-tune versus use prompt engineering. You'll understand when distributed training becomes necessary and which parallelism strategy applies to your model size. You'll evaluate which deployment platform makes economic sense for your volume and latency requirements.</p>

<h2>Part II Will Teach You To Ask "Which?"</h2>

<p>The next chapters examine architectural choices that determine whether projects succeed or exceed budgets by 10√ó:</p>

<p><strong>Training at Scale (Chapter 4):</strong> When does distributed training make sense? Your team proposes 8-GPU training for a model that fits in single-GPU memory. Should you approve the 8√ó hardware cost for potential speedup? Chapter 4 provides the decision framework‚Äîdata parallelism achieves 7.5√ó speedup on 8 GPUs (94\% efficiency) when the model fits in memory, making it economically favorable for training runs exceeding 2 days.</p>

<p><strong>Production Deployment (Chapter 5):</strong> Which compression technique applies to your constraints? Vendors offer quantization (4√ó compression, less than 1\% accuracy loss), distillation (3√ó compression, less than 1\% accuracy loss), and pruning (2√ó compression, less than 1\% accuracy loss). Chapter 5's Compression-Quality Frontier mental model guides you through the 4-level compression ladder, showing when each investment pays off based on your request volume.</p>

<p><strong>Advanced Techniques (Chapter 6):</strong> Should you fine-tune or optimize prompts? Your team proposes fine-tuning (\$25K, 3 weeks) to improve classification accuracy from 78\% to 91\%. Chapter 6's Prompt-Finetune Decision Tree walks you through the 4-step process‚Äîtry zero-shot, try few-shot, optimize prompts systematically, then fine-tune only if prompts fail. Most projects stop at step 3, saving \$20K.</p>

<p><strong>Hardware Infrastructure (Chapter 7):</strong> Cloud versus on-premise‚Äîwhich makes economic sense? The decision depends on utilization rates, volume predictability, and 3-year TCO. Chapter 7 provides the calculation framework showing when fixed costs of on-premise infrastructure become favorable over variable costs of cloud APIs.</p>

<p><strong>Data Pipeline (Chapter 8):</strong> How much training data do you actually need? Proposals often specify "100K labeled examples" without justification. Chapter 8 reveals the relationship between data quantity, model size, and expected performance, helping you challenge over-specified data requirements that waste months and hundreds of thousands of dollars on unnecessary labeling.</p>

<p><strong>Operationalization (Chapter 9):</strong> What's the total cost of ownership? Training cost is visible, but operational costs‚Äîretraining frequency, monitoring infrastructure, incident response‚Äîoften exceed training costs by 10√ó. Chapter 9 provides the full lifecycle cost framework, preventing the common mistake of optimizing training while ignoring the operational expenses that dominate long-term budgets.</p>

<h2>Key Questions for Part II</h2>

<p>As you read the next chapters, you'll develop frameworks to answer:</p>

<ol>
    <li>Your team proposes fine-tuning. Should you try prompt engineering first? What's the economic breakpoint?
    <li>Training is estimated at 10 GPU-days. Can you speed it up? At what cost? When does parallelism pay off?
    <li>The model works in development. What changes for production deployment? What optimizations are mandatory versus optional?
    <li>Which hardware platform makes sense? What's the 3-year TCO comparison between cloud and on-premise?
    <li>How often will you need to retrain? What's the ongoing operational cost, not just the initial training investment?
</ol>

<p>These architectural decisions determine whether projects succeed on time and on budget or fail expensively. Part I gave you the foundation to understand costs. Part II gives you the frameworks to make the right choices.</p>

<div style="text-align: center;">
<em>The difference between a \$50K project and a \$500K project is usually architectural choices, not implementation quality.</em>
</div>
<div class="chapter-nav">
  <a href="chapter03_attention_fundamentals.html">‚Üê Chapter 3: Attention Fundamentals</a>
  <a href="../../leadership.html">üìö Table of Contents</a>
  <a href="chapter04_training_transformers.html">Chapter 4: Training Transformers ‚Üí</a>
</div>
</main>
    <footer><p>&copy; 2026 Deep Learning and LLMs for Technical Leaders.</p></footer>
</body>
</html>