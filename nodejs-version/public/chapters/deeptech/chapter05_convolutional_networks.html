<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chapter 5: Convolutional Neural Networks - Deep Learning and Transformers</title>
    <link rel="stylesheet" href="../../styles.css">
    
    <!-- MathJax Configuration (must come before loading MathJax) -->
    <script>
    window.MathJax = {
        tex: {
            inlineMath: [['$', '$'], ['\\(', '\\)']],
            displayMath: [['$$', '$$'], ['\\[', '\\]']],
            processEscapes: true,
            processEnvironments: true,
            tags: 'ams',
            macros: {
                R: '{\\mathbb{R}}',
                N: '{\\mathbb{N}}',
                Z: '{\\mathbb{Z}}',
                C: '{\\mathbb{C}}',
                va: '{\\mathbf{a}}',
                vb: '{\\mathbf{b}}',
                vc: '{\\mathbf{c}}',
                vd: '{\\mathbf{d}}',
                ve: '{\\mathbf{e}}',
                vf: '{\\mathbf{f}}',
                vg: '{\\mathbf{g}}',
                vh: '{\\mathbf{h}}',
                vi: '{\\mathbf{i}}',
                vj: '{\\mathbf{j}}',
                vk: '{\\mathbf{k}}',
                vl: '{\\mathbf{l}}',
                vm: '{\\mathbf{m}}',
                vn: '{\\mathbf{n}}',
                vo: '{\\mathbf{o}}',
                vp: '{\\mathbf{p}}',
                vq: '{\\mathbf{q}}',
                vr: '{\\mathbf{r}}',
                vs: '{\\mathbf{s}}',
                vt: '{\\mathbf{t}}',
                vu: '{\\mathbf{u}}',
                vv: '{\\mathbf{v}}',
                vw: '{\\mathbf{w}}',
                vx: '{\\mathbf{x}}',
                vy: '{\\mathbf{y}}',
                vz: '{\\mathbf{z}}',
                mA: '{\\mathbf{A}}',
                mB: '{\\mathbf{B}}',
                mC: '{\\mathbf{C}}',
                mD: '{\\mathbf{D}}',
                mE: '{\\mathbf{E}}',
                mF: '{\\mathbf{F}}',
                mG: '{\\mathbf{G}}',
                mH: '{\\mathbf{H}}',
                mI: '{\\mathbf{I}}',
                mJ: '{\\mathbf{J}}',
                mK: '{\\mathbf{K}}',
                mL: '{\\mathbf{L}}',
                mM: '{\\mathbf{M}}',
                mN: '{\\mathbf{N}}',
                mO: '{\\mathbf{O}}',
                mP: '{\\mathbf{P}}',
                mQ: '{\\mathbf{Q}}',
                mR: '{\\mathbf{R}}',
                mS: '{\\mathbf{S}}',
                mT: '{\\mathbf{T}}',
                mU: '{\\mathbf{U}}',
                mV: '{\\mathbf{V}}',
                mW: '{\\mathbf{W}}',
                mX: '{\\mathbf{X}}',
                mY: '{\\mathbf{Y}}',
                mZ: '{\\mathbf{Z}}',
                transpose: '{^\\top}',
                norm: ['\\left\\|#1\\right\\|', 1],
                abs: ['\\left|#1\\right|', 1]
            }
        },
        startup: {
            pageReady: () => {
                console.log('MathJax loaded and ready');
                return MathJax.startup.defaultPageReady();
            }
        }
    };
    </script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>
    <nav>
        <a href="../../deeptech.html">üè† Home</a>
        <a href="preface.html">Preface</a>
        <a href="notation.html">Notation</a>
        <a href="chapter01_linear_algebra.html">Ch 1</a>
        <a href="chapter02_calculus_optimization.html">Ch 2</a>
        <a href="chapter03_probability_information.html">Ch 3</a>
        <a href="chapter04_feedforward_networks.html">Ch 4</a>
        <a href="chapter05_convolutional_networks.html">Ch 5</a>
        <a href="chapter06_recurrent_networks.html">Ch 6</a>
        <a href="chapter07_attention_fundamentals.html">Ch 7</a>
        <a href="chapter08_self_attention.html">Ch 8</a>
        <a href="chapter09_attention_variants.html">Ch 9</a>
        <a href="chapter10_transformer_model.html">Ch 10</a>
        <a href="chapter11_training_transformers.html">Ch 11</a>
        <a href="chapter12_computational_analysis.html">Ch 12</a>
        <a href="chapter13_bert.html">Ch 13</a>
        <a href="chapter14_gpt.html">Ch 14</a>
        <a href="chapter15_t5_bart.html">Ch 15</a>
        <a href="chapter16_efficient_transformers.html">Ch 16</a>
        <a href="chapter17_vision_transformers.html">Ch 17</a>
        <a href="chapter18_multimodal_transformers.html">Ch 18</a>
        <a href="chapter19_long_context.html">Ch 19</a>
        <a href="chapter20_pretraining_strategies.html">Ch 20</a>
        <a href="chapter21_pytorch_implementation.html">Ch 21</a>
        <a href="chapter22_hardware_optimization.html">Ch 22</a>
        <a href="chapter23_best_practices.html">Ch 23</a>
        <a href="chapter24_domain_specific_models.html">Ch 24</a>
        <a href="chapter25_enterprise_nlp.html">Ch 25</a>
        <a href="chapter26_code_language.html">Ch 26</a>
        <a href="chapter27_video_visual.html">Ch 27</a>
        <a href="chapter28_knowledge_graphs.html">Ch 28</a>
        <a href="chapter29_recommendations.html">Ch 29</a>
        <a href="chapter30_healthcare.html">Ch 30</a>
        <a href="chapter31_finance.html">Ch 31</a>
        <a href="chapter32_legal.html">Ch 32</a>
        <a href="chapter33_observability.html">Ch 33</a>
        <a href="chapter34_dsl_agents.html">Ch 34</a>
    </nav>

    <main>
        <h1>Convolutional Neural Networks</h1>

<h2>Chapter Overview</h2>

<p>Convolutional Neural Networks (CNNs) revolutionized computer vision by exploiting spatial structure. This chapter develops convolution operations, pooling, and modern CNN architectures including ResNet.</p>

<h3>Learning Objectives</h3>

<ol>
    <li>Understand convolution operations and compute output dimensions
    <li>Design CNN architectures with appropriate pooling and stride
    <li>Understand translation equivariance
    <li>Implement modern CNN architectures (ResNet, VGG)
</ol>

<h2>Convolution Operation</h2>

<div class="definition"><strong>Definition:</strong> 
For input $\mX \in \R^{H \times W}$ and kernel $\mK \in \R^{k_h \times k_w}$:
<div class="equation">
$$
(\mX \star \mK)_{i,j} = \sum_{m=0}^{k_h-1} \sum_{n=0}^{k_w-1} \mX_{i+m, j+n} \cdot \mK_{m,n}
$$
</div>
</div>

<figure>
\begin{tikzpicture}[
    cell/.style={rectangle, draw, minimum size=0.5cm, font=\footnotesize},
    kernel/.style={rectangle, draw, fill=blue!20, minimum size=0.5cm, font=\footnotesize},
    output/.style={rectangle, draw, fill=green!20, minimum size=0.6cm, font=\small},
    arrow/.style={->, >=stealth, thick}
]

<p>\foreach \i in {0,...,4} {
    \foreach \j in {0,...,4} {
        \node[cell] (in\i\j) at (\j*0.6, -\i*0.6) {};
    }
}</p>

<p>\foreach \i in {0,1,2} {
    \foreach \j in {0,1,2} {
        \node[kernel] at (\j*0.6, -\i*0.6) {};
    }
}</p>

<p>\foreach \i in {0,1,2} {
    \foreach \j in {0,1,2} {
        \node[kernel] (k\i\j) at (4.5+\j*0.6, -\i*0.6) {$w$};
    }
}</p>

<p>\foreach \i in {0,1,2} {
    \foreach \j in {0,1,2} {
        \node[output] (out\i\j) at (7.5+\j*0.8, -\i*0.8) {};
    }
}</p>

<p>\node[output, fill=green!50] at (7.5, 0) {$y_{11}$};</p>

<p>\draw[arrow, red, thick] (1.2, -1.2) -- (4.2, -0.5);
\draw[arrow, blue, thick] (5.7, -0.5) -- (7.3, -0.2);</p>

<p>\end{tikzpicture}</p>

<p><strong>Convolution:</strong> Only $3 \times 3 = 9$ connections (parameter sharing!)</p>

<p>\caption{Convolutional layer receptive field showing local connectivity. Each output neuron (green) connects only to a local $3 \times 3$ patch of the input (blue highlighted region), not to all input positions. The same $3 \times 3$ kernel weights are shared across all spatial positions, dramatically reducing parameters compared to fully-connected layers. For a $5 \times 5$ input, a fully-connected layer would require 25 weights per output, while convolution requires only 9 weights total (shared across all outputs).}
<figcaption>CNN receptive field showing local connectivity. Each output neuron connects to a local $3 \times 3$ region of the input (highlighted in blue), not all inputs. The same kernel weights are shared across all spatial positions, enabling parameter efficiency and translation invariance.</figcaption>
</figure>

<div class="example"><strong>Example:</strong> 
Input $4\times4$, kernel $3\times3$ (edge detector), output $2\times2$. Computing first position: sum of element-wise products gives edge response.
</div>

<h3>Output Dimensions</h3>

<div class="theorem"><strong>Theorem:</strong> 
For input size $H \times W$, kernel $k_h \times k_w$, padding $p$, stride $s$:
<div class="equation">
$$
H_{\text{out}} = \left\lfloor \frac{H + 2p - k_h}{s} \right\rfloor + 1
$$
</div>
</div>

<h2>Multi-Channel Convolutions</h2>

<div class="definition"><strong>Definition:</strong> 
For input $\mathbf{X} \in \R^{C_{\text{in}} \times H \times W}$ with $C_{\text{out}}$ output channels:
<div class="equation">
$$
\mathbf{Y}^{(i)} = \sum_{c=1}^{C_{\text{in}}} \mathbf{X}^{(c)} \star \mathbf{K}^{(i,c)} + b^{(i)}
$$
</div>
</div>

<div class="example"><strong>Example:</strong> 
Input: $\mathbf{X} \in \R^{3 \times 224 \times 224}$. Conv layer: 64 filters $3\times3$, stride 1, padding 1.

<p>Parameters: $64 \times 3 \times 3 \times 3 + 64 = 1{,}792$</p>

<p>Output: $\mathbf{Y} \in \R^{64 \times 224 \times 224}$</p>

<p>Compare to fully-connected: $\approx 483$ billion parameters!
</div>

<div class="keypoint">
Convolution provides: (1) Parameter sharing, (2) Local connectivity, (3) Translation equivariance. Massive parameter reduction compared to fully-connected layers.
</div>

<h2>Computational Analysis of Convolutions</h2>

<p>Understanding the computational cost and memory requirements of convolutional layers is essential for designing efficient architectures and comparing CNNs with alternative approaches like transformers. The relationship between parameters, FLOPs, and memory usage in convolutions differs fundamentally from fully-connected layers, leading to distinct performance characteristics on modern hardware.</p>

<h3>FLOPs for Convolution Operations</h3>

<p>The computational cost of a convolutional layer is determined by the number of multiply-accumulate operations required to compute all output feature maps. For a convolutional layer with input shape $C_{\text{in}} \times H \times W$, kernel size $k \times k$, and $C_{\text{out}}$ output channels, each output position requires $C_{\text{in}} \times k \times k$ multiply-accumulate operations. With output spatial dimensions $H_{\text{out}} \times W_{\text{out}}$ and $C_{\text{out}}$ output channels, the total FLOPs is:</p>

<div class="equation">
$$
\text{FLOPs}_{\text{conv}} = 2 \times C_{\text{out}} \times C_{\text{in}} \times k^2 \times H_{\text{out}} \times W_{\text{out}}
$$
</div>

<p>The factor of 2 accounts for the multiply-accumulate operation (one multiplication and one addition per operation). This formula reveals that convolution FLOPs scale linearly with both input and output channels, quadratically with kernel size, and linearly with output spatial dimensions.</p>

<p>For the RGB convolution example in Example~[ref] with input $3 \times 224 \times 224$, kernel size $3 \times 3$, and 64 output channels with stride 1 and padding 1, the output dimensions are $64 \times 224 \times 224$. The FLOPs calculation is $2 \times 64 \times 3 \times 9 \times 224 \times 224 = 173{,}408{,}192$ FLOPs, or approximately 173 MFLOPs. Despite having only 1,792 parameters, this layer requires 173 million floating-point operations, giving a FLOPs-to-parameter ratio of approximately 96,768. This ratio is dramatically higher than fully-connected layers, which have a FLOPs-to-parameter ratio of approximately 2-3.</p>

<p>The high FLOPs-to-parameter ratio of convolutions has important implications for model design. Convolutional layers are compute-intensive relative to their memory footprint, making them well-suited for modern GPUs that have abundant compute throughput but limited memory bandwidth. A ResNet-50 model with 25.6 million parameters requires approximately 4.1 billion FLOPs for a single forward pass on a $224 \times 224$ image, giving an overall FLOPs-to-parameter ratio of 160. This means that during training, the computational cost dominates over the memory cost of loading parameters, and GPU utilization is primarily limited by compute throughput rather than memory bandwidth.</p>

<p>The scaling behavior of convolution FLOPs explains several architectural design choices in modern CNNs. Early layers operating on high-resolution feature maps ($224 \times 224$ or larger) consume the majority of FLOPs despite having relatively few parameters. For ResNet-50, the first convolutional layer with kernel size $7 \times 7$ and 64 output channels accounts for only 0.4\% of parameters but 5.8\% of total FLOPs. Conversely, later layers operating on low-resolution feature maps ($7 \times 7$ or smaller) have many parameters but relatively few FLOPs. The final fully-connected layer in ResNet-50 accounts for 7.8\% of parameters but only 0.1\% of FLOPs. This distribution motivates the use of larger kernels and more channels in early layers (where spatial dimensions are large) and smaller kernels with many channels in later layers (where spatial dimensions are small).</p>

<h3>Memory Requirements for Feature Maps</h3>

<p>During training, convolutional networks must store intermediate feature maps for use in the backward pass, and these activations typically consume far more memory than the model parameters. Understanding activation memory is critical for determining maximum batch size and input resolution.</p>

<p>For a convolutional layer with input shape $B \times C_{\text{in}} \times H \times W$ (where $B$ is batch size) and output shape $B \times C_{\text{out}} \times H_{\text{out}} \times W_{\text{out}}$, the network must store both the input feature map and the output feature map. In FP32, this requires $4B(C_{\text{in}} HW + C_{\text{out}} H_{\text{out}} W_{\text{out}})$ bytes of memory. For the RGB convolution example with batch size $B = 32$, input $3 \times 224 \times 224$, and output $64 \times 224 \times 224$, the activation memory is $4 \times 32 \times (3 \times 224 \times 224 + 64 \times 224 \times 224) = 130{,}809{,}792$ bytes, or approximately 125 MB. This is 70,000√ó larger than the parameter memory (1,792 parameters = 7,168 bytes), demonstrating that activation memory dominates for convolutional layers.</p>

<p>The memory consumption of a full CNN scales with the number of layers and the spatial dimensions of feature maps. For ResNet-50 processing batch size 32 with input $3 \times 224 \times 224$, the total activation memory is approximately 8.2 GB in FP32. This includes the input image (6.4 MB), early high-resolution feature maps (hundreds of MB), and later low-resolution feature maps (tens of MB). The parameter memory for ResNet-50 is only 102 MB (25.6 million parameters √ó 4 bytes), making activations 80√ó larger than parameters. This ratio increases with batch size: at batch size 256, activations consume 65.6 GB while parameters remain 102 MB, a ratio of 643√ó.</p>

<p>The quadratic scaling of activation memory with spatial resolution has profound implications for input image size. Doubling the input resolution from $224 \times 224$ to $448 \times 448$ increases the number of pixels by 4√ó, and since early feature maps maintain similar spatial dimensions to the input, activation memory increases by approximately 4√ó. For ResNet-50 with batch size 32, increasing resolution from $224 \times 224$ to $448 \times 448$ increases activation memory from 8.2 GB to approximately 32.8 GB, exceeding the capacity of most GPUs. This explains why high-resolution image processing typically requires smaller batch sizes or gradient accumulation: the activation memory grows faster than available GPU memory.</p>

<p>Modern techniques for reducing activation memory include gradient checkpointing, which recomputes activations during the backward pass rather than storing them, trading computation for memory. For ResNet-50, gradient checkpointing can reduce activation memory by 5-10√ó at the cost of increasing training time by 20-30\%. This trade-off is often worthwhile for training with larger batch sizes or higher resolutions, as the improved convergence from larger batches can offset the increased computation time.</p>

<h3>GPU Optimization: im2col and Winograd</h3>

<p>Efficient implementation of convolution on GPUs requires specialized algorithms that transform the convolution operation into a form amenable to highly optimized matrix multiplication routines. The two primary approaches are im2col (image-to-column) and Winograd convolution, each with distinct performance characteristics.</p>

<p>The im2col algorithm transforms convolution into matrix multiplication by unrolling the input feature map into a large matrix where each column contains the input values for one output position. For a convolutional layer with input $C_{\text{in}} \times H \times W$, kernel size $k \times k$, and output $C_{\text{out}} \times H_{\text{out}} \times W_{\text{out}}$, im2col creates a matrix of shape $(C_{\text{in}} k^2) \times (H_{\text{out}} W_{\text{out}})$ by extracting all $k \times k$ patches from the input. The convolution kernels are reshaped into a matrix of shape $C_{\text{out}} \times (C_{\text{in}} k^2)$. The convolution is then computed as a single matrix multiplication: $\text{output} = \text{kernels} \times \text{im2col}(\text{input})$, producing a matrix of shape $C_{\text{out}} \times (H_{\text{out}} W_{\text{out}})$ that is reshaped to the final output dimensions.</p>

<p>For the RGB convolution example with input $3 \times 224 \times 224$, kernel size $3 \times 3$, and 64 output channels, im2col creates a matrix of shape $27 \times 50{,}176$ (since $C_{\text{in}} k^2 = 3 \times 9 = 27$ and $H_{\text{out}} W_{\text{out}} = 224 \times 224 = 50{,}176$). The kernel matrix has shape $64 \times 27$. The matrix multiplication $64 \times 27$ times $27 \times 50{,}176$ requires $2 \times 64 \times 27 \times 50{,}176 = 173{,}408{,}192$ FLOPs, matching the direct convolution calculation. However, the im2col matrix requires $27 \times 50{,}176 \times 4 = 5{,}419{,}008$ bytes (5.2 MB) of temporary storage, which is 757√ó larger than the original input (7,168 bytes for $3 \times 224 \times 224$ in FP32).</p>

<p>The advantage of im2col is that it leverages highly optimized BLAS (Basic Linear Algebra Subprograms) libraries like cuBLAS on NVIDIA GPUs, which achieve 80-95\% of peak hardware throughput for large matrix multiplications. For the $64 \times 27$ times $27 \times 50{,}176$ multiplication on an NVIDIA A100 GPU with 312 TFLOPS FP16 throughput, the operation completes in approximately 0.6 microseconds at 90\% efficiency, achieving 280 TFLOPS. Direct convolution implementations without im2col typically achieve only 40-60\% efficiency due to irregular memory access patterns and difficulty saturating the GPU's parallel execution units.</p>

<p>The disadvantage of im2col is the memory overhead. For batch size $B = 32$, the im2col matrix grows to $32 \times 27 \times 50{,}176 = 43{,}352{,}064$ elements, requiring 167 MB of temporary storage. This memory must be allocated and deallocated for each convolutional layer, adding memory pressure and potentially causing out-of-memory errors for large batch sizes or high-resolution inputs. Modern implementations mitigate this by processing the batch in chunks or fusing the im2col transformation with the matrix multiplication to avoid materializing the full im2col matrix.</p>

<p>Winograd convolution is an alternative algorithm that reduces the number of multiplications required for small convolutions (typically $3 \times 3$ or $5 \times 5$ kernels) by using a mathematical transformation that trades multiplications for additions. For $3 \times 3$ convolutions, Winograd reduces the number of multiplications by 2.25√ó compared to direct convolution, from 9 multiplications per output to 4 multiplications per output. This reduction translates directly to FLOPs savings: the RGB convolution example requires only $173{,}408{,}192 / 2.25 = 77{,}070{,}752$ FLOPs with Winograd, a 56\% reduction.</p>

<p>However, Winograd convolution has several limitations. First, it requires additional memory for intermediate transformations, typically 2-3√ó the input size. Second, it is numerically less stable than direct convolution, particularly in FP16, due to the transformation matrices having large condition numbers. Third, it is only applicable to small kernel sizes ($3 \times 3$ and $5 \times 5$) and becomes inefficient for larger kernels. Fourth, the transformation overhead becomes significant for small spatial dimensions, making Winograd most effective for early layers with large feature maps.</p>

<p>In practice, modern deep learning frameworks like PyTorch and TensorFlow automatically select between im2col, Winograd, and direct convolution based on layer dimensions, batch size, and hardware characteristics. For $3 \times 3$ convolutions on high-resolution feature maps ($\geq 56 \times 56$) with batch size $\geq 16$, Winograd typically provides 1.5-2√ó speedup over im2col. For larger kernels ($5 \times 5$ or $7 \times 7$) or smaller feature maps, im2col is preferred. For very small batch sizes ($\leq 4$), direct convolution may be fastest due to lower overhead. NVIDIA's cuDNN library implements all three algorithms and includes heuristics to select the optimal approach for each layer configuration.</p>

<h3>Comparison with Transformer Attention</h3>

<p>Comparing the computational characteristics of convolutional layers with transformer self-attention reveals fundamental trade-offs between local and global receptive fields, parameter efficiency, and computational scaling.</p>

<p>A convolutional layer with kernel size $k \times k$ has a local receptive field: each output position depends only on a $k \times k$ neighborhood of the input. To achieve a global receptive field spanning the entire input, multiple convolutional layers must be stacked. For an input of size $H \times W$, achieving a receptive field covering the full input requires approximately $\log_k(\max(H, W))$ layers. For a $224 \times 224$ image with $3 \times 3$ convolutions, this requires approximately $\log_3(224) \approx 5$ layers. Each layer adds computational cost, but the cost per layer remains $O(C_{\text{out}} C_{\text{in}} k^2 HW)$, scaling linearly with spatial dimensions.</p>

<p>In contrast, self-attention in transformers has a global receptive field: each output position attends to all input positions in a single layer. For an input sequence of length $n = HW$ (treating the 2D image as a 1D sequence) with model dimension $d$, self-attention requires computing query-key products for all pairs of positions, resulting in $O(n^2 d)$ FLOPs. For a $224 \times 224$ image with $n = 50{,}176$ positions and $d = 768$ (typical for Vision Transformers), self-attention requires approximately $2 \times 50{,}176^2 \times 768 = 3.86 \times 10^{12}$ FLOPs, or 3.86 TFLOPs per layer. This is 22,000√ó more expensive than the RGB convolution example (173 MFLOPs), despite both operating on the same input resolution.</p>

<p>The quadratic scaling of attention with spatial resolution makes it prohibitively expensive for high-resolution images. Doubling the resolution from $224 \times 224$ to $448 \times 448$ increases attention FLOPs by 16√ó (since $n$ increases by 4√ó and attention scales as $n^2$), while convolution FLOPs increase by only 4√ó (linear scaling with spatial dimensions). For a $448 \times 448$ image, self-attention requires 61.8 TFLOPs per layer, making it impractical without modifications like hierarchical attention or local attention windows.</p>

<p>Vision Transformers (ViTs) address this computational challenge by dividing the image into patches and treating each patch as a token. For a $224 \times 224$ image with patch size $16 \times 16$, the sequence length is $n = (224/16)^2 = 196$ patches. Self-attention on 196 patches with $d = 768$ requires $2 \times 196^2 \times 768 = 59{,}015{,}168$ FLOPs, or approximately 59 MFLOPs per layer. This is 65√ó less expensive than attention on individual pixels and comparable to the RGB convolution example (173 MFLOPs). However, the patch-based approach sacrifices fine-grained spatial resolution: each patch is treated as a single token, and the model cannot attend to individual pixels within a patch.</p>

<p>The parameter efficiency of convolutions versus attention also differs significantly. A convolutional layer with $C_{\text{in}}$ input channels, $C_{\text{out}}$ output channels, and kernel size $k \times k$ has $C_{\text{out}} C_{\text{in}} k^2$ parameters. For the RGB convolution example, this is $64 \times 3 \times 9 = 1{,}728$ parameters. A self-attention layer with model dimension $d$ has query, key, and value projection matrices, each of size $d \times d$, totaling $3d^2$ parameters (ignoring the output projection). For $d = 768$, this is $3 \times 768^2 = 1{,}769{,}472$ parameters, which is 1,024√ó more than the convolutional layer. However, the attention parameters are independent of spatial resolution, while convolution parameters are independent of spatial resolution as well. The key difference is that attention parameters scale with $d^2$ while convolution parameters scale with $C_{\text{in}} C_{\text{out}} k^2$, and typically $d \gg C_{\text{in}}$ for early layers.</p>

<p>For complete models, ResNet-50 has 25.6 million parameters and requires 4.1 GFLOPs per image, while ViT-Base has 86 million parameters and requires 17.6 GFLOPs per image. The ViT has 3.4√ó more parameters and 4.3√ó more FLOPs, but achieves comparable or better accuracy on ImageNet classification. The higher computational cost of ViT is offset by its ability to leverage large-scale pretraining on datasets like ImageNet-21k or JFT-300M, where the global receptive field and flexibility of attention provide advantages over the inductive biases of convolution.</p>

<div class="keypoint">
CNNs are significantly more parameter-efficient than transformers for vision tasks due to weight sharing and local connectivity. ResNet-50 achieves 76.1\% ImageNet accuracy with 25.6M parameters, while ViT-Base requires 86M parameters for comparable accuracy. However, Vision Transformers excel when large-scale pretraining data is available. A detailed comparison of CNNs and Vision Transformers is provided in Chapter~17.
</div>

<div class="keypoint">
Efficient convolution on GPUs requires channel dimensions that are multiples of 16 (for Tensor Core alignment) and sufficient batch size to saturate parallel compute units. Libraries like cuDNN automatically select optimal algorithms (im2col, Winograd, FFT) and apply kernel fusions. Early CNN layers are typically memory-bandwidth-bound while later layers are compute-bound. For a detailed treatment of hardware optimization, see Chapter~22.
</div>

<h2>Pooling Layers</h2>

<div class="definition"><strong>Definition:</strong> 
For window $k \times k$ and stride $s$:
<div class="equation">
$$
\text{MaxPool}(\mathbf{X})_{i,j} = \max_{m,n \in \text{window}} \mathbf{X}_{si+m, sj+n}
$$
</div>
</div>

<p>Pooling reduces spatial dimensions, increases receptive field, and provides translation invariance.</p>

<h2>Classic Architectures</h2>

<h3>VGG-16 (2014)</h3>

<p>Deep network with small $3\times3$ filters. Pattern: $[\text{Conv}3\times3]^n \to \text{MaxPool} \to \text{Double channels}$</p>

<p>Total: 138 million parameters</p>

<h3>ResNet (2015)</h3>

<div class="definition"><strong>Definition:</strong> 
Learn residual:
<div class="equation">
$$
\mathbf{y} = \mathcal{F}(\mathbf{x}) + \mathbf{x}
$$
</div>
</div>

<p>ResNet-50: 25.6M parameters, enables training 100+ layer networks.</p>

<div class="keypoint">
Residual connections enable extremely deep networks by allowing gradients to flow through skip connections. Analogous to skip connections in transformers.
</div>

<h2>Batch Normalization</h2>

<div class="definition"><strong>Definition:</strong> 
For mini-batch, normalize each feature:
<div class="equation">
$$\begin{align}
\hat{\mathbf{x}}_i &= \frac{\mathbf{x}_i - \mu_{\mathcal{B}}}{\sqrt{\sigma^2_{\mathcal{B}} + \epsilon}} \\
\mathbf{y}_i &= \gamma \hat{\mathbf{x}}_i + \beta
\end{align}$$
</div>
where $\gamma, \beta$ are learnable.
</div>

<p>Benefits: Reduces covariate shift, allows higher learning rates, acts as regularization.</p>

<h2>Exercises</h2>

<div class="exercise" id="exercise-1"><strong>Exercise 1:</strong> For $32\times32\times3$ input, compute dimensions after: Conv(64, $5\times5$, s=1, p=2), MaxPool($2\times2$, s=2), Conv(128, $3\times3$, s=1, p=1), MaxPool($2\times2$, s=2). Count parameters.
</div>

<div class="exercise" id="exercise-2"><strong>Exercise 2:</strong> Show two $3\times3$ convolutions equal one $5\times5$ receptive field. Compare parameter counts.
</div>

<div class="exercise" id="exercise-3"><strong>Exercise 3:</strong> Design CNN for CIFAR-10 with 3 blocks, channels [64, 128, 256]. Calculate total parameters.
</div>

<h2>Solutions</h2>

<p>Full solutions for all exercises are available at \url{https://deeplearning.hofkensvermeulen.be}.</p>

<div class="solution"><strong>Solution:</strong> Starting with input $32\times32\times3$:

<p><strong>Conv1 (64 filters, $5\times5$, stride=1, padding=2):</strong>
<div class="equation">
$$
H_{\text{out}} = \frac{32 + 2(2) - 5}{1} + 1 = \frac{32 + 4 - 5}{1} + 1 = 32
$$
</div>
Output: $32\times32\times64$</p>

<p>Parameters: $(5 \times 5 \times 3 + 1) \times 64 = 76 \times 64 = 4{,}864$</p>

<p><strong>MaxPool1 ($2\times2$, stride=2):</strong>
<div class="equation">
$$
H_{\text{out}} = \frac{32 - 2}{2} + 1 = 16
$$
</div>
Output: $16\times16\times64$</p>

<p>Parameters: 0 (pooling has no learnable parameters)</p>

<p><strong>Conv2 (128 filters, $3\times3$, stride=1, padding=1):</strong>
<div class="equation">
$$
H_{\text{out}} = \frac{16 + 2(1) - 3}{1} + 1 = 16
$$
</div>
Output: $16\times16\times128$</p>

<p>Parameters: $(3 \times 3 \times 64 + 1) \times 128 = 577 \times 128 = 73{,}856$</p>

<p><strong>MaxPool2 ($2\times2$, stride=2):</strong>
<div class="equation">
$$
H_{\text{out}} = \frac{16 - 2}{2} + 1 = 8
$$
</div>
Output: $8\times8\times128$</p>

<p><strong>Total parameters:</strong> $4{,}864 + 73{,}856 = 78{,}720$
</div>

<div class="solution"><strong>Solution:</strong> <strong>Receptive field analysis:</strong>

<p><strong>Single $5\times5$ convolution:</strong>
<ul>
    <li>Receptive field: $5\times5 = 25$ pixels
    <li>Parameters per output channel: $5 \times 5 \times C_{\text{in}} + 1$
    <li>For $C_{\text{in}} = C_{\text{out}} = 64$: $(25 \times 64 + 1) \times 64 = 102{,}464$ parameters
</ul>

<p><strong>Two $3\times3$ convolutions:</strong>
<ul>
    <li>First $3\times3$ conv: receptive field $3\times3$
    <li>Second $3\times3$ conv: each output pixel sees $3\times3$ region of previous layer
    <li>Each pixel in previous layer sees $3\times3$ region of input
    <li>Total receptive field: $3 + (3-1) = 5$ in each dimension, so $5\times5$
</ul>

<p><strong>Parameter count for two $3\times3$ convolutions:</strong>
<ul>
    <li>First conv: $(3 \times 3 \times 64 + 1) \times 64 = 36{,}928$ parameters
    <li>Second conv: $(3 \times 3 \times 64 + 1) \times 64 = 36{,}928$ parameters
    <li>Total: $73{,}856$ parameters
</ul>

<p><strong>Comparison:</strong>
<div class="equation">
$$
\text{Reduction} = \frac{102{,}464 - 73{,}856}{102{,}464} \approx 28\%
$$
</div>

<p>Two $3\times3$ convolutions achieve the same receptive field as one $5\times5$ with 28\% fewer parameters, plus an additional nonlinearity between them, increasing representational power.
</div>

<div class="solution"><strong>Solution:</strong> <strong>CNN architecture for CIFAR-10 (10 classes):</strong>

<p>Input: $32\times32\times3$</p>

<p><strong>Block 1 (64 channels):</strong>
<ul>
    <li>Conv: $3\times3$, 64 filters, stride=1, padding=1 $\to$ $32\times32\times64$
    <li>Conv: $3\times3$, 64 filters, stride=1, padding=1 $\to$ $32\times32\times64$
    <li>MaxPool: $2\times2$, stride=2 $\to$ $16\times16\times64$
</ul>

<p>Parameters:
<ul>
    <li>Conv1: $(3 \times 3 \times 3 + 1) \times 64 = 1{,}792$
    <li>Conv2: $(3 \times 3 \times 64 + 1) \times 64 = 36{,}928$
    <li>Block 1 total: $38{,}720$
</ul>

<p><strong>Block 2 (128 channels):</strong>
<ul>
    <li>Conv: $3\times3$, 128 filters, stride=1, padding=1 $\to$ $16\times16\times128$
    <li>Conv: $3\times3$, 128 filters, stride=1, padding=1 $\to$ $16\times16\times128$
    <li>MaxPool: $2\times2$, stride=2 $\to$ $8\times8\times128$
</ul>

<p>Parameters:
<ul>
    <li>Conv1: $(3 \times 3 \times 64 + 1) \times 128 = 73{,}856$
    <li>Conv2: $(3 \times 3 \times 128 + 1) \times 128 = 147{,}584$
    <li>Block 2 total: $221{,}440$
</ul>

<p><strong>Block 3 (256 channels):</strong>
<ul>
    <li>Conv: $3\times3$, 256 filters, stride=1, padding=1 $\to$ $8\times8\times256$
    <li>Conv: $3\times3$, 256 filters, stride=1, padding=1 $\to$ $8\times8\times256$
    <li>MaxPool: $2\times2$, stride=2 $\to$ $4\times4\times256$
</ul>

<p>Parameters:
<ul>
    <li>Conv1: $(3 \times 3 \times 128 + 1) \times 256 = 295{,}168$
    <li>Conv2: $(3 \times 3 \times 256 + 1) \times 256 = 590{,}080$
    <li>Block 3 total: $885{,}248$
</ul>

<p><strong>Classifier:</strong>
<ul>
    <li>Global Average Pooling: $4\times4\times256 \to 1\times1\times256$
    <li>Fully connected: $256 \to 10$
    <li>Parameters: $256 \times 10 + 10 = 2{,}570$
</ul>

<p><strong>Total parameters:</strong>
<div class="equation">
$$
38{,}720 + 221{,}440 + 885{,}248 + 2{,}570 = 1{,}147{,}978 \approx 1.15\text{M parameters}
$$
</div>
</div>
        
        <div class="chapter-nav">
  <a href="chapter04_feedforward_networks.html">‚Üê Chapter 4: Feed-Forward Neural Networks</a>
  <a href="../../deeptech.html">üìö Table of Contents</a>
  <a href="chapter06_recurrent_networks.html">Chapter 6: Recurrent Neural Networks ‚Üí</a>
</div>

    </main>

    <footer>
        <p>&copy; 2026 Deep Learning and Transformers Textbook. All rights reserved.</p>
    </footer>

    <script src="../js/main.js"></script>
</body>
</html>
